<!DOCTYPE HTML>
<html>

<head>
    <title>Mandelbrott</title>
    <style type="text/css">
        html {
            /* overflow:hidden; */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
        }

        .window {
            display: flex;
            flex-direction: column;
            align-items: baseline;
            border: none;
            background-color: rgba(60, 59, 66, 0.93);
            -webkit-box-shadow: 0px 0px 6.5px rgba(0, 0, 0, 0.3);
            -moz-box-shadow: 0px 0px 6.5px rgba(0, 0, 0, 0.3);
            box-shadow: 0px 0px 6.5px rgba(0, 0, 0, 0.3);
            user-select: none;
            position: relative;
            /* Set initial width and height */
            width: fit-content;
            height: fit-content;
            border: 1px solid rgba(0, 0, 0, 0);
            transition: border-color 0.3s ease;
        }

        .window-anchored {
            background-color: rgba(0, 0, 0, 0.82);
            /* Change this to the desired color */
        }

            .window-anchored::before {
                content: "";
                display: block;
                position: absolute;
                top: -1px;
                left: -1px;
                right: -1px;
                bottom: -1px;
                border: 2px solid #bbb;
                pointer-events: none;
                z-index: 1;
            }

        .window:hover::before {
            content: "";
            display: block;
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border: 2px solid #bbb;
            pointer-events: none;
            z-index: 1;
        }

        .window.selected::before {
            content: "";
            display: block;
            position: absolute;
            top: -1px;
            left: -1px;
            right: -1px;
            bottom: -1px;
            border: 2px solid #007BFF;
            pointer-events: none;
            z-index: 5;
        }

        .title-input {
            color: #bbb;
            background: none !important;
            border-style: solid;
            border-width: 3px 3px 0px 0;
            border-color: #aaa;
            transform: translate(-2%, 10%);
            transition: border-color 0.3s ease;
            /* Add transition for smooth color change */
        }

            .title-input:focus {
                border-color: #bbb;
                /* Change the border color when the input is focused */
                outline: none;
                /* Remove the default outline */
            }

        .resize-container {
            position: absolute;
            flex-grow: 1;
            bottom: 0;
            right: 0;
            width: 15px;
            height: 15px;
            pointer-events: auto;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            /* Add this line */
        }

        .resize-handle {
            position: absolute;
            width: 15px;
            height: 15px;
            bottom: -8px;
            /* Adjust this value */
            right: -8px;
            cursor: nwse-resize;
            z-index: 4;
            pointer-events: auto;
            /* Add this line */
        }

        iframe {
            width: 100%;
            height: 100%;
            min-width: 300px;
            min-height: 200px;
            background-color: white;
        }

        .content {
            width: fit-content;
            height: fit-content;
            box-sizing: border-box;
            /* Add this line */
        }

        .resize-handle::before {
            content: "";
            position: absolute;
            width: 2px;
            height: 10px;
            background-color: #bbb;
            transform-origin: 0 0;
        }

        .resize-handle::after {
            content: "";
            position: absolute;
            width: 2.8px;
            height: 5px;
            background-color: #bbb;
            transform-origin: 0 0;
        }

        .resize-handle::before {
            transform: rotate(45deg) translate(-1px, -4px) scale(.9);
        }

        .resize-handle::after {
            transform: rotate(45deg) translate(3px, -1px) scale(.5);
        }

        .resize-handle.dragging {
            background-color: none;
        }

        .selectable {
            user-select: auto;
        }

        #elements svg g {
            z-index: 10;
            display: inline-block;
        }

        * {
            font-family: "Open Sans", sans-serif;
            color: #bbb;
        }

        .disable-pointer-events {
            pointer-events: none;
        }

        .search_matched {
            outline-style: double;
            outline-color: red;
            outline-width: 10px;
        }

        .search_nomatch {
            outline-style: hidden;
            outline-color: blue;
            outline-width: 0px;
        }

        /* Dropdown menu styles */

        .dropdown {
            position: absolute;
            top: 20px;
            right: 20px;
        }

        .menu-button {
            position: relative;
            width: 40px;
            height: 40px;
            cursor: pointer;
            z-index: 2;
        }

        .menu-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 2px;
            background-color: #bbb;
            transition: all 0.3s ease-in-out;
            z-index: 10; /* higher than dropdown-content */
        }

            .menu-icon::before,
            .menu-icon::after {
                content: "";
                position: absolute;
                width: 20px;
                height: 2px;
                background-color: #bbb;
                transition: all 0.3s ease-in-out;
            }

            .menu-icon::before {
                top: -6px;
            }

            .menu-icon::after {
                bottom: -6px;
            }

        .menu-button.open .menu-icon {
            background-color: transparent;
        }

            .menu-button.open .menu-icon::before {
                transform: translateY(6px) rotate(45deg);
            }

            .menu-button.open .menu-icon::after {
                transform: translateY(-6px) rotate(-45deg);
            }

        .dropdown-content {
            position: absolute;
            top: 100%; /* modify if needed */
            right: 0; /* modify if needed */
            background: rgba(60, 59, 66, 0.9);
            border-top-right-radius: 8px;
            border-bottom-left-radius: 8px;
            overflow: hidden;
            display: none;
            z-index: 1;
            margin-top: -38px; /* negative margin */
            margin-right: -5px; /* negative margin */
        }

            .dropdown-content.open {
                display: block;
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: 1fr;
                grid-column-gap: 0px;
                grid-row-gap: 0px;
                -webkit-box-shadow: 0px 0px 30px 10px rgba(21, 21, 27, 0.44);
                -moz-box-shadow: 0px 0px 30px 10px rgba(21, 21, 27, 0.44);
                box-shadow: 0px 0px 30px 10px rgba(21, 21, 27, 0.44);
            }

        .submenu {
            padding: 10px;
            color: #bbb
        }

            .submenu a {
                display: block;
                color: #bbb;
                text-decoration: none;
                padding: 5px;
            }

                .submenu a.selected:before {
                    content: "\2713";
                    color: #bbb;
                    margin-right: 5px;
                }

                .submenu a:hover {
                    background-color: #ddd;
                }

        input[type="range"] {
            display: block;
            margin: 0 auto;
            width: 200px;
        }

        input[type="text"i] {
            padding: 1px 2px;
            background-color: #222226;
            color: #bbb;
            border: inset;
            border-color: #8882;
        }

        .submenu-btn {
            display: flex;
            align-content: flex-start;
            border: none;
            background-color: transparent;
            color: #bbb;
            cursor: pointer;
            padding: 5px;
            font-size: medium;
        }

        .Searchbar {
            background-color: #222226;
            color: #bbb;
            width: 153px;
            border: inset;
            border-color: #8882;
        }

        .gradient-selector {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .gradient-preview {
            width: 250px;
            height: 100px;
            margin-top: 5px;
        }

        .color-inputs {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }

        .color-input {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 5px;
        }

        .color-picker {
            width: 50px;
            height: 50px;
            background-color: #8882;
            color: #bbb
        }

        .delete-btn {
            margin-top: 5px;
            background-color: #8882;
            color: #bbb
        }

        .add-btn {
            margin-top: 10px;
            background-color: #8882;
            display: flex;
            justify-content: center !important;
            width: auto;
            color: #bbb;
        }

        .search_matched {
            outline-style: double;
            outline-color: red;
            outline-width: 10px;
        }

        .search_nomatch {
            outline-style: hidden;
            outline-color: blue;
            outline-width: 0px;
        }

        .textnode {
            background-color: #222226;
        }

        #prompt-form {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        textarea#prompt {
            overflow-y: hidden;
            flex-grow: 1;
            background-color: #222226;
            color: inherit;
            border: inset;
            border-color: #8882;
            width: 270px;
            padding: 10px;
            box-sizing: border-box;
            resize: none;
        }

        #prompt-form button {
            z-index: 1;
            padding: 4px 6px;
            font-size: 14px;
            cursor: pointer;
            background-color: #222226;
            transition: background-color 0.3s;
            border: inset;
            border-color: #8882;
        }

            #prompt-form button:hover {
                background-color: #ddd;
                color: #222226
            }

            #prompt-form button[type="submit"] {
                background-color: #222226;
                color: white;
            }

                #prompt-form button[type="submit"]:hover {
                    background-color: #45a049;
                }

        #api-key-input {
            margin-bottom: 10px;
            background-color: #222226;
            color: #bbb;
            border: inset;
            border-color: #8882;
        }

        .linkbuttons {
            padding: 4px 6px;
            font-size: 14px;
            cursor: pointer;
            background-color: #222226;
            transition: background-color 0.3s;
            border: inset;
            border-color: #8882;
        }

            .linkbuttons:hover {
                background-color: #ddd;
            }

            .linkbuttons[type="submit"] {
                background-color: #222226;
                color: #bbb;
            }

                .linkbuttons[type="submit"]:hover {
                    background-color: #45a049;
                }

        .checkboxarray {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: space-between;
            width: 300px;
            /* adjust this as needed */
        }

            .checkboxarray div {
                width: 33%;
                /* adjust this as needed */
            }

        .tabs {
            display: flex;
            justify-content: flex-start;
        }

        .tabcontent {
            display: none;
        }

        .tablink {
            padding: 4px 6px;
            font-size: 14px;
            cursor: pointer;
            background-color: #222226;
            transition: background-color 0.3s;
            border: inset;
            border-color: #8882;
        }

            .tablink:hover {
                background-color: #ddd;
                color: #222226;
                /* Change text color on hover so it's visible against the lighter background */
            }

        .input-group {
            display: flex;
            align-items: start;
        }

        .btn-group button {
            width: 30px;
            /* Adjust as needed */
            height: 30px;
            /* Adjust as needed */
        }

        .btn-group {
            display: flex;
            flex-direction: column;
            align-items: start;
            gap: 5px;
            padding-left: 6px;
            width: 30px;
            height: 20px;
        }

        .zettelkasten {
            background-color: #222226;
            width: 261px;
            z-index: -1;
            border: inset;
            border-color: #8882;
            resize: vertical;
            /* only allows the height to be resizable */
        }

            .zettelkasten::-webkit-scrollbar {
                width: 10px;
            }

            .zettelkasten::-webkit-scrollbar-thumb {
                background: #888;
            }

                .zettelkasten::-webkit-scrollbar-thumb:hover {
                    background: #555;
                }

            .zettelkasten::-webkit-scrollbar-corner {
                background: transparent;
                border: none;
            }

        .howto {
            width: auto;
        }

        table {
            border-collapse: collapse;
            width: 400px;
            background-color: #222226;
        }

        th,
        td {
            padding: 15px;
            text-align: center;
            border: 1px solid #ddd;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
        }

            .custom-scrollbar::-webkit-scrollbar-thumb:hover {
                background: #555;
            }

        .custom-scrollbar::-webkit-scrollbar-corner {
            background: transparent;
            border: none;
        }

        .key-button {
            z-index: 1;
            padding: 4px 6px;
            font-size: 14px;
            cursor: pointer;
            background-color: #222226;
            transition: background-color 0.3s;
            border: inset;
            border-color: #8882;
        }

            .key-button:hover {
                background-color: #ddd;
                color: #222226;
            }

        .google-key-input input {
            background-color: #222226;
            border: inset;
            border-color: #8882;
        }

        .model-selector {
            border: 1px solid #222226;
            background-color: #222226;
            border: inset;
            border-color: #8882;
        }

        .model-input {
            background-color: #222226;
            border: inset;
            border-color: #8882;
        }

        #wolframApiKey {
            background-color: #222226;
            border: inset;
            border-color: #8882;
        }

        #howto {
            max-height: 500px; /* adjust this value as needed */
            overflow-y: auto;
        }

        #clickable-link {
            color: #0572eb;
            text-decoration: underline;
        }

            #clickable-link:hover {
                color: #0572eb;
                text-decoration: none;
            }

            #clickable-link:visited {
                color: #652fc5;
            }

        #svg_bg {
            width: 100%;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
    </style>
</head>

<body id="body">

    <div ondragover="dragOverHandler(event);" ondrop="dropHandler(event);" style="width: 100%; height: 100vh; overflow: hidden;">
        <svg id="svg_bg" viewBox="-128 -128 256 256" style="width: 100%; height: 100%;">
            <title>Mandelbrot</title>
            <g id="viewmatrix">
                <g id="bg" />
                <path id="mousePath" d="" fill="none" stroke="red" stroke-width="0.01" />
                <g id="edges" />
            </g>
        </svg>
    </div>

    <script>
        //https://github.com/tc39/proposal-regex-escaping/blob/main/specInJs.js
        // this is a direct translation to code of the spec
        if (!RegExp.escape) {
            RegExp.escape = (S) => {
                // 1. let str be ToString(S).
                // 2. ReturnIfAbrupt(str).
                let str = String(S);
                // 3. Let cpList be a List containing in order the code
                // points as defined in 6.1.4 of str, starting at the first element of str.
                let cpList = Array.from(str[Symbol.iterator]());
                // 4. let cuList be a new List
                let cuList = [];
                // 5. For each code point c in cpList in List order, do:
                for (let c of cpList) {
                    // i. If c is a SyntaxCharacter then do:
                    if ("^$\\.*+?()[]{}|".indexOf(c) !== -1) {
                        // a. Append "\" to cuList.
                        cuList.push("\\");
                    }
                    // Append c to cpList.
                    cuList.push(c);
                }
                //6. Let L be a String whose elements are, in order, the elements of cuList.
                let L = cuList.join("");
                // 7. Return L.
                return L;
            };
        }
    </script>

    <svg id="debug_layer" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" style="position: absolute; left:0px; top:0px; display:none; visibility:hidden; width: 100%; height: 100vh;">
        <style>
            .white {
                font: 12px sans-serif;
                fill: white;
            }
        </style>
        <text x="0" y="0" class="white">fps:</text>
    </svg>



    <div class="dropdown">
        <div class="menu-button">
            <div class="menu-icon"></div>
        </div>
        <div class="dropdown-content">
            <div style="display: none;" id="search-results">
                <div class="submenu">

                </div>
            </div>
            <div>
                <div class="tabs">
                    <button class="tablink" onclick="openTab('tab1', this)">Notes</button>
                    <button class="tablink" onclick="openTab('tab4', this)">Ai</button>
                    <button class="tablink" onclick="openTab('tab2', this)">Settings</button>
                    <button class="tablink" onclick="openTab('tab3', this)">?</button>
                </div>

                <div id="tab1" class="tabcontent">
                    <!-- First tab content here -->
                    <div class="submenu">
                        <input id="Searchbar" class="Searchbar" placeholder="search notes..." />
                        <br />
                        <br />
                        <form id="prompt-form" onsubmit="sendMessage(event);">
                            <div class="input-group">
                                <textarea id="prompt" rows="1" onkeydown="handleKeyDown(event);" oninput="autoGrow(event);" placeholder="Enter prompt..." required></textarea>

                                <div class="btn-group">
                                    <button type="submit">⏵</button>

                                    <button id="regen-button" type="button">↺</button>
                                </div>
                            </div>
                        </form>
                        <br />
                        <textarea id="note-input" class="zettelkasten" rows="10" cols="50"></textarea>
                        <br />
                        <div class="checkboxarray">
                            <div>
                                <input type="checkbox" id="google-search-checkbox" name="enable-search">
                                <label for="google-search-checkbox">: Search</label>

                            </div>
                            <div>
                                <input type="checkbox" id="code-checkbox" name="code-checkbox">
                                <label for="code-checkbox">: Code</label>
                            </div>
                            <div>
                                <input type="checkbox" id="auto-mode-checkbox">
                                <label for="auto-mode-checkbox">: Auto</label>
                            </div>
                            <div>
                                <input type="checkbox" id="embed-checkbox">
                                <label for="embed-checkbox">: Extracts</label>
                            </div>
                            <div>
                                <input type="checkbox" id="enable-wolfram-alpha" name="enable-wolfram-alpha">
                                <label for="enable-wolfram-alpha">: Wolfram</label>
                            </div>
                            <div>
                                <input type="checkbox" id="wiki-checkbox">
                                <label for="wiki-checkbox">: Wiki</label>


                            </div>
                        </div>
                    </div>
                </div>

                <div id="tab2" class="tabcontent">
                    <!-- Second tab content here -->
                    <div class="submenu">
                        <br />
                        <a id="save-button">Save</a>
                        <input id="save-or-load" type="text" placeholder="save data..." />
                        <a id="load-button">Load</a>
                        <a id="clear-button">Clear</a>
                        <div id="clear-sure" style="display:none">
                            <a id="clear-unsure-button">no</a>
                            <a id="clear-sure-button">yes</a>
                        </div>
                        <br />
                        <input type="text" id="node-tag" class="tags" value="node:" />
                        <label for="node-tag"></label>
                        <br />
                        <input type="text" id="ref-tag" class="tags" value="ref:" />
                        <label for="ref-tag"></label>
                        <br />
                        <br />
                        <div id="quality_value">Quality</div>
                        <input id="quality" type="range" min="0" max="100" value="0">
                        <div id="length_value">Length</div>
                        <input id="length" type="range" min="0" max="100" value="50">
                        z <sup id="exponent_value" style="color: powderblue">2</sup> + c
                        <input id="exponent" type="range" min="1" max="8" value="2">
                        <br />
                        <div id="coordinates" style="background-color: none;background-color: none; color:none; position: inherit; display: initial; left: 0px; top: 0px;">
                            pan:
                            <input id="pan" type="text" value="0+0i" style="background:none; border:none;" size="50" />
                            <br />
                            zoom:
                            <input id="zoom" type="text" value="1" style="background:none; border:none;" size="28" />
                            <br />
                            <br />
                            <div id="fps" style="display:flex; justify-content:flex-start;">fps:?? (is javascript enabled?)</div>


                        </div>
                    </div>
                </div>

                <div id="tab3" class="tabcontent">
                    <div id="howto" class="howto custom-scrollbar">
                        <table>
                            <tr>
                                <td><input type="checkbox" id="instructions-checkbox"><label for="instructions-checkbox"><br /><strong> AI HOW-TO</strong></label></td>
                                <td>Sends a context message to the AI that enables it to explain the website and its controls.</td>
                            </tr>
                            <tr>
                                <td><a href="https://github.com/satellitecomponent/Neurite" id="clickable-link">Github Link</a></td>
                                <td>Visit our Github for extended documentation.</td>
                            </tr>
                            <tr>
                                <td><strong>CLICK AND DRAG</strong></td>
                                <td>Move around the fractal.</td>
                            </tr>
                            <tr>
                                <td>
                                    <strong>
                                        SCROLL WHEEL
                                        <br />PINCH on touchpad
                                    </strong>
                                </td>
                                <td>Zoom in/out.</td>
                            </tr>
                            <tr>
                                <td><strong>ALT + SCROLL</strong></td>
                                <td>Rotate the view.</td>
                            </tr>
                            <tr>
                                <td><strong>SHIFT + DOUBLE CLICK</strong></td>
                                <td>Creates a text node</td>
                            </tr>
                            <tr>
                                <td><strong>DOUBLE CLICK</strong></td>
                                <td>'Anchor' a window in place.</td>
                            </tr>
                            <tr>
                                <td><strong>SHIFT (hold)</strong></td>
                                <td>Toggle 'Node-Mode'. <br />Freezes Windows</td>
                            </tr>
                            <tr>
                                <td><strong>SHIFT + SCROLL</strong></td>
                                <td>Resize a window.</td>
                            </tr>
                            <tr>
                                <td>ALT + CLICK</td>
                                <td>Selects multiple nodes. Allows for multiple nodes to be re-scaled</td>
                            </tr>
                            <tr>
                                <td>LocalHost Servers</td>
                                <td>Wiki, Wolfram, and Webpage Extraction currently require setting up of personal localhosts.<br />Visit the Github link for more information.<br /> The Ai How-To Checkbox at the top of the instructions will allow the ai to explain basic set-up.</td>
                            </tr>
                        </table>
                    </div>
                </div>
                <div id="tab4" class="tabcontent">
                    <!-- Fourth tab content here -->
                    <div class="submenu">
                        <div>
                            <label for="api-key-input">OpenAI API Key:</label>
                            <input type="password" id="api-key-input">
                        </div>

                        <div class="google-key-input">
                            <label for="googleApiKey">Google API Key:</label>
                            <input type="password" id="googleApiKey">
                        </div>
                        <div class="google-key-input">
                            <label for="googleSearchEngineId">Google Search Engine ID:</label>
                            <input type="password" id="googleSearchEngineId">
                        </div>
                        <div class="wolfram-key-input">
                            <label for="wolframApiKey">Wolfram API Key:</label>
                            <input type="password" id="wolframApiKey">
                        </div>
                        <br />
                        <button class="key-button" onclick="saveKeys()">Save Keys</button>
                        <button class="key-button" onclick="clearKeys()">Clear Keys</button>
                        <br />
                        <br />
                        <div>
                            <label for="model-select">Choose a model:</label>
                            <select id="model-select" class="model-selector" onchange="checkOtherModel(this)">
                                <option value="gpt-3.5-turbo">GPT-3.5 Turbo</option>
                                <option value="gpt-4">GPT-4</option>
                                <option value="other">Other...</option>
                            </select>
                            <input id="model-input" class="model-input" style="display: none;" placeholder="Enter model name">
                            <input id="model-input" style="display: none;" placeholder="Enter model name">
                        </div>
                        <label for="max-tokens-slider">Max Tokens: <span id="max-tokens-display">2000</span></label>
                        <input type="range" id="max-tokens-slider" name="max-tokens-slider" min="1" max="32000" value="2000">
                        <label id="model-temperature-label" for="model-temperature">Model Temperature: 0.1</label>
                        <input type="range" id="model-temperature" name="model-temperature" class="slider" min="0" max="1" step="0.1" value="0.1" onchange="updateLabel()">
                        <br />
                        <p>Webpage Extraction</p>
                        <div>
                            <label for="topN">Top <span id="topNValue">5</span> Webpage Excerpts</label>
                            <input type="range" id="topNSlider" name="topN" min="1" max="100" value="5">

                        </div>
                        <div class="slidecontainer">
                            <p>Max Chunk Size: <span id="maxChunkSizeValue"></span></p>
                            <input type="range" min="1" max="8191" value="400" class="slider" id="maxChunkSizeSlider">
                        </div>
                        <br />
                        <input type="checkbox" id="novelty-checkbox"><label for="novelty-checkbox"><strong>: Novelty <br />(Shuffled Wiki Results)</strong></label>
                    </div>
                </div>
            </div>
        </div>
        <script type="text/javascript" src="https://cdn.jsdelivr.net/pyodide/v0.23.0/full/pyodide.js"></script>
        <script>
            function updateLabel() {
                const temperature = document.getElementById('model-temperature').value;
                document.getElementById('model-temperature-label').innerText = 'Model Temperature: ' + temperature;
            }

            // Load any saved keys from local storage
            document.getElementById('googleApiKey').value = localStorage.getItem('googleApiKey') || '';
            document.getElementById('googleSearchEngineId').value = localStorage.getItem('googleSearchEngineId') || '';
            document.getElementById('api-key-input').value = localStorage.getItem('openaiApiKey') || '';
            document.getElementById('wolframApiKey').value = localStorage.getItem('wolframApiKey') || '';

            function saveKeys() {
                // Save keys to local storage
                localStorage.setItem('googleApiKey', document.getElementById('googleApiKey').value);
                localStorage.setItem('googleSearchEngineId', document.getElementById('googleSearchEngineId').value);
                localStorage.setItem('openaiApiKey', document.getElementById('api-key-input').value);
                localStorage.setItem('wolframApiKey', document.getElementById('wolframApiKey').value);
            }

            function clearKeys() {
                // Clear keys from local storage
                localStorage.removeItem('googleApiKey');
                localStorage.removeItem('googleSearchEngineId');
                localStorage.removeItem('openaiApiKey');
                localStorage.removeItem('wolframApiKey');

                // Clear input fields
                document.getElementById('googleApiKey').value = '';
                document.getElementById('googleSearchEngineId').value = '';
                document.getElementById('api-key-input').value = '';
                document.getElementById('wolframApiKey').value = '';
            }

            function handleKeyDown(event) {
                if (event.key === 'Enter') {
                    if (event.shiftKey) {
                        // Shift + Enter was pressed, submit the form
                        event.preventDefault();
                        sendMessage(event);
                    } else {
                        // Enter was pressed without Shift, insert a newline
                        event.preventDefault();
                        // insert a newline at the cursor
                        const cursorPosition = event.target.selectionStart;
                        event.target.value = event.target.value.substring(0, cursorPosition) + "\n" + event.target.value.substring(cursorPosition);
                        // position the cursor after the newline
                        event.target.selectionStart = cursorPosition + 1;
                        event.target.selectionEnd = cursorPosition + 1;
                        // force the textarea to resize
                        autoGrow(event);
                    }
                }
                return true;
            }

            function autoGrow(event) {
                const textarea = event.target;
                // Temporarily make the height 'auto' so the scrollHeight is not affected by the current height
                textarea.style.height = 'auto';
                let maxHeight = 200; // your desired maximum height
                if (textarea.scrollHeight < maxHeight) {
                    textarea.style.height = textarea.scrollHeight + 'px';
                    textarea.style.overflowY = 'hidden';
                } else {
                    textarea.style.height = maxHeight + 'px';
                    textarea.style.overflowY = 'auto';
                }
            }



            //disable ctl +/- zoom on browser
            document.addEventListener('keydown', (event) => {
                if (event.ctrlKey && (event.key === '+' || event.key === '-' || event.key === '=')) {
                    event.preventDefault();
                }
            });

            document.addEventListener('wheel', (event) => {
                if (event.ctrlKey) {
                    event.preventDefault();
                }
            }, {
                passive: false
            });

            document.body.style.transform = "scale(1)";
            document.body.style.transformOrigin = "0 0";

            var nodeTagInput;
            var refTagInput;
            {

                const nodeTableBody = document.getElementById('node-table-body');
                nodeTagInput = document.getElementById('node-tag');
                refTagInput = document.getElementById('ref-tag');
                const noteInput = document.getElementById('note-input');
                const nodes = {};
                const nodeLines = {};
                const draggableWindows = document.querySelectorAll('.window');

                draggableWindows.forEach((draggableWindow) => {
                    draggableWindow.addEventListener('mousedown', (event) => {
                        draggableWindows.forEach((otherWindow) => {
                            if (otherWindow !== draggableWindow) {
                                otherWindow.classList.add('disable-pointer-events');
                            }
                        });
                    });

                    draggableWindow.addEventListener('mouseup', (event) => {
                        draggableWindows.forEach((otherWindow) => {
                            if (otherWindow !== draggableWindow) {
                                otherWindow.classList.remove('disable-pointer-events');
                            }
                        });
                    });
                });

                function nodeRE(name = undefined, tag_prefix = undefined) {
                    if (tag_prefix === undefined) {
                        tag_prefix = nodeTagInput.value;
                    }
                    if (name === undefined) {
                        return new RegExp("(\\n|^)" + RegExp.escape(tag_prefix));
                    }
                    return new RegExp("(\\n|^)" + RegExp.escape(tag_prefix) + "[\t ]*" + RegExp.escape(name) + "[\t ]*(\n|$)");
                }

                function renameNode(from, to) {
                    //(\n|^)(((#node:)[\t ]*from[\t ]*)|((#ref:)([^,\n]+,)*[\t ]*from[\t ]*(,[^,\n]+)*))(?=(\n|$))
                    //$1$4$6$7 to$8$9
                    const fe = RegExp.escape(from);
                    const nodeRE = "(" + RegExp.escape(nodeTagInput.value) + ")[\\t ]*" + fe + "[\\t ]*";
                    const refRE = "(" + RegExp.escape(refTagInput.value) + ")([^,\\n]+,)*[\\t ]*" + fe + "[\\t ]*(,[^,\\n]+)*";
                    const tag = "((" + nodeRE + ")|(" + refRE + "))";
                    const re = new RegExp("(\n|^)" + tag + "(?=(\n|$))", "g");
                    const replacer = (match, p1, p2, p3, p4, p5, p6, p7, p8, p9, offset, string, groups) => {
                        return p1 + (p4 ? p4 + " " : "") + (p6 ? p6 + " " : "") + (p7 || "") + to + (p8 || "");
                    }
                    return (s) => s.replace(re, replacer);
                }

                function processInput() {
                    const nodeTag = nodeTagInput.value;
                    const refTag = refTagInput.value;

                    for (const key in nodes) {
                        if (nodes[key].nodeObject.removed) {
                            delete nodes[key];
                        } else {
                            nodes[key].plainText = '';
                            nodes[key].ref = '';
                            nodes[key].live = false;
                        }
                    }

                    const lines = noteInput.value.split('\n');
                    let currentNodeTitle = '';

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];

                        if (line.startsWith(nodeTag)) {
                            currentNodeTitle = line.substr(nodeTag.length).trim();
                            if (!nodes[currentNodeTitle] || nodes[currentNodeTitle].nodeObject.removed) {
                                if (nodeLines[i] && !nodeLines[i].nodeObject.removed) {
                                    const node = nodes[currentNodeTitle] = nodeLines[i];
                                    if (nodes[node.title] === node) {
                                        delete nodes[node.title];
                                    }
                                    node.title = currentNodeTitle;
                                    node.live = true;
                                    node.nodeObject.content.children[0].children[0].children[1].value = currentNodeTitle;
                                } else {
                                    const node = nodeLines[i] = nodes[currentNodeTitle] = {
                                        title: currentNodeTitle,
                                        plainText: '',
                                        ref: '',
                                        live: true,
                                        nodeObject: createTextNode(currentNodeTitle, '', (Math.random() - 0.5) * 1.8, (Math.random() - 0.5) * 1.8),
                                        edges: new Map(),
                                        lineNum: i,
                                    };

                                    node.nodeObject.content.children[0].children[0].children[1].addEventListener('input', (e) => {
                                        const name = node.title;
                                        let newName = node.nodeObject.content.children[0].children[0].children[1].value.trim();
                                        newName = newName.replace(",", "");
                                        if (newName === node.title) {
                                            return;
                                        }
                                        delete nodes[name];
                                        if (nodes[newName]) {
                                            let count = 2;
                                            while (nodes[newName + "(" + count + ")"]) {
                                                count++;
                                            }
                                            newName += "(" + count + ")";
                                            node.nodeObject.content.children[0].children[0].children[1].value = newName;
                                        }
                                        nodes[newName] = node;
                                        node.title = newName;
                                        const f = renameNode(name, node.nodeObject.content.children[0].children[0].children[1].value);
                                        noteInput.value = f(noteInput.value);
                                    });
                                    node.nodeObject.content.children[0].children[1].children[0].addEventListener('input', (e) => {
                                        const body = node.nodeObject.content.children[0].children[1].children[0].value;
                                        //just replace between #node: [name] and the next tag
                                        const name = node.title;
                                        const nt = RegExp.escape(nodeTagInput.value);
                                        const start = "((\\n|^)" + nt + "[\\t ]*" + RegExp.escape(name) + "[\\t ]*(\\n|$))";
                                        const rt = RegExp.escape(refTagInput.value);
                                        const end = "(?=((\\n" + nt + ")|(\\n" + rt + ")|$))";

                                        const re = new RegExp(start + "((?=((" + nt + ")|(" + rt + ")|$))|(([^]*?)" + end + "))");

                                        noteInput.value = noteInput.value.replace(re, (match, p1, p2, p3, p4, p5, p6, p7, offset, string, groups) => {
                                            p1 = p1 || "";
                                            if (!p1.endsWith("\n")) {
                                                p1 += "\n";
                                            }
                                            if (p5 !== undefined) {
                                                return p1 + body + "\n";
                                            }
                                            return p1 + body;
                                        });
                                    });
                                }
                            } else {
                                nodes[currentNodeTitle].plainText = "";
                                nodes[currentNodeTitle].nodeObject.content.children[0].children[1].children[0].value = nodes[currentNodeTitle].plainText;
                                if (nodeLines[nodes[currentNodeTitle].lineNum] === nodes[currentNodeTitle]) {
                                    delete nodeLines[nodes[currentNodeTitle].lineNum];
                                }
                                nodes[currentNodeTitle].live = true;
                                nodes[currentNodeTitle].lineNum = i;
                                nodeLines[i] = nodes[currentNodeTitle];
                            }
                        } else if (line.startsWith(refTag)) {
                            if (currentNodeTitle !== '') {
                                const references = line.substr(refTag.length).split(',').map(ref => ref.trim());
                                const thisNode = nodes[currentNodeTitle];
                                references.forEach(reference => {
                                    if (nodes[reference]) {
                                        if (!thisNode.edges.has(reference)) {
                                            thisNode.edges.set(reference, connectDistance(thisNode.nodeObject, nodes[reference].nodeObject));
                                        }
                                    }
                                });
                                const refset = new Set(references);
                                for (const ref of thisNode.edges.keys()) {
                                    if (!refset.has(ref)) {
                                        thisNode.edges.get(ref).remove();
                                        thisNode.edges.delete(ref);
                                    }
                                }
                            }
                        } else {
                            if (currentNodeTitle !== '') {
                                if (nodes[currentNodeTitle].plainText !== '') {
                                    nodes[currentNodeTitle].plainText += '\n';
                                }
                                nodes[currentNodeTitle].plainText += line;
                                const targetTextarea = nodes[currentNodeTitle].nodeObject.content.children[0].children[1].children[0];
                                targetTextarea.value = nodes[currentNodeTitle].plainText;

                                // Manually call the adjustTextareaHeight function to adjust the textarea height
                                adjustTextareaHeight(targetTextarea);
                            }
                        }
                    } {
                        const dels = [];
                        for (const k in nodes) {
                            if (!nodes[k].live) {
                                nodes[k].nodeObject.remove();
                                dels.push(k);
                            }
                        }
                        for (const k of dels) {
                            delete nodes[k];
                        }
                    } {
                        const dels = [];
                        for (const k in nodeLines) {
                            if (!nodeLines[k].live) {
                                nodeLines[k].nodeObject.remove();
                                dels.push(k);
                            }
                        }
                        for (const k of dels) {
                            delete nodeLines[k];
                        }
                    }

                    //updateTable();
                }

                document.getElementById('note-input').addEventListener('input', processInput);
                nodeTagInput.addEventListener('input', processInput);
                refTagInput.addEventListener('input', processInput);

                function updateTable() {
                    nodeTableBody.innerHTML = '';

                    for (const nodeTitle in nodes) {
                        const node = nodes[nodeTitle];

                        const row = document.createElement('tr');
                        const headerCell = document.createElement('td');
                        const plainTextCell = document.createElement('td');
                        const refCell = document.createElement('td');

                        headerCell.textContent = node.title;
                        row.appendChild(headerCell);
                        plainTextCell.textContent = node.nodeObject.content.children[0].children[1].children[0].value.trim();
                        refCell.innerHTML = node.ref.trim();
                        row.appendChild(plainTextCell);
                        row.appendChild(refCell);

                        nodeTableBody.appendChild(row);
                    }
                }

                //processInput();
            }

            function connectDistance(na, nb, linkStrength = .1, linkStyle = {
                stroke: "none",
                "stroke-width": "0.005",
                fill: "lightcyan",
                opacity: "0.5"
            }) {
                // Calculate the distance between the two nodes
                const dx = nb.pos.x - na.pos.x;
                const dy = nb.pos.y - na.pos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                let edge = new Edge([na, nb], distance, linkStrength, linkStyle);

                na.addEdge(edge);

                edges.push(edge);
                return edge;
            }
        </script>
    </div>
    </div>

    <script>
        function openTab(tabId, element) {
            var i, tabcontent, tablinks;

            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }

            tablinks = document.getElementsByClassName("tablink");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }

            document.getElementById(tabId).style.display = "block";
            element.className += " active";
        }

        // Get the menu button and dropdown content elements
        const menuButton = document.querySelector(".menu-button");
        const dropdownContent = document.querySelector(".dropdown-content");

        // Get the first tabcontent element
        const firstTab = document.querySelector(".tabcontent");

        dropdownContent.addEventListener("paste", function (e) {
            cancel(e);
        });
        dropdownContent.addEventListener("wheel", function (e) {
            cancel(e);
        });
        dropdownContent.addEventListener("dblclick", function (e) {
            cancel(e);
        });

        // Add an event listener to the menu button
        menuButton.addEventListener("click", function (event) {
            // Prevent the click event from propagating
            event.stopPropagation();

            // Toggle the "open" class on the menu button and dropdown content
            menuButton.classList.toggle("open");
            dropdownContent.classList.toggle("open");

            // If the dropdown is opened, manually set the first tab to active and display its content
            if (dropdownContent.classList.contains("open")) {
                var tablinks = document.getElementsByClassName("tablink");
                var tabcontent = document.getElementsByClassName("tabcontent");

                // Remove active class from all tablinks and hide all tabcontent
                for (var i = 0; i < tablinks.length; i++) {
                    tablinks[i].classList.remove("active");
                    tabcontent[i].style.display = "none";
                }

                // Open the first tab
                openTab('tab1', tablinks[0]);

                // If there's any selected text, deselect it
                if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                } else if (document.selection) {
                    document.selection.empty();
                }
            }
        });


        dropdownContent.addEventListener("mousedown", (e) => {
            cancel(e);
        });




        document.getElementById("save-button").addEventListener("click", function () {
            let s = document.getElementById("nodes").innerHTML;
            //navigator.clipboard.writeText(s);
            //console.log("save",s);
            document.getElementById("save-or-load").value = s;
        });
        document.getElementById("load-button").addEventListener("click", function () {
            loadnet(document.getElementById("save-or-load").value, true);
        });
        // Get all the menu items
        const menuItems = document.querySelectorAll(".menu-item");

        // Add a click event listener to each menu item
        menuItems.forEach(function (item) {
            item.addEventListener("click", function () {
                // Remove the "selected" class from all the menu items
                // menuItems.forEach(function(item) {
                //   item.classList.remove("selected");
                // });

                // Add the "selected" class to the clicked menu item
                item.classList.add("selected");
            });
        });
        document.getElementById("clear-button").addEventListener("click", function () {
            document.getElementById("clear-sure").setAttribute("style", "display:block");
            document.getElementById("clear-button").text = "Are you sure?";
        });
        document.getElementById("clear-unsure-button").addEventListener("click", function () {
            document.getElementById("clear-sure").setAttribute("style", "display:none");
            document.getElementById("clear-button").text = "clear";
        });
        document.getElementById("clear-sure-button").addEventListener("click", function () {
            clearnet();
            document.getElementById("clear-sure").setAttribute("style", "display:none");
            document.getElementById("clear-button").text = "clear";
        });

        function getQuality() {
            let v = document.getElementById("quality").value / 100;
            return 2 ** (v * 4);
        }
        document.getElementById("quality").addEventListener("input", (e) => {
            let v = getQuality();
            setRenderQuality(v);
            document.getElementById("quality_value").textContent = "Quality:" + (Math.round(v * 100) / 100);
        });

        function getLength() {
            let v = document.getElementById("length").value / 100;
            return 2 ** (v * 8);
        }
        document.getElementById("length").addEventListener("input", (e) => {
            let v = getLength();
            setRenderLength(v);
            document.getElementById("length_value").textContent = "Length:" + (Math.round(v * 100) / 100);
        });
        document.getElementById("exponent").addEventListener("input", (e) => {
            let v = e.target.value * 1;
            mand_step = (z, c) => {
                return z.ipow(v).cadd(c);
            }
            document.getElementById("exponent_value").textContent = v;
        })
        const submenuBtn = document.querySelector('.submenu-btn');
    </script>









    <a id="nodes">

        <!-- add stuff here -->

    </a>
    <!--iframe id="inlineFrameExample"
            title="Inline Frame Example"
            width="150"
            height="100"
            src="https://m.media-amazon.com/images/M/MV5BOTY2NDY4OGUtYWE0Ni00NWZiLWI3NDktYmE2YWM3Njc3YmRkXkEyXkFqcGdeQXVyMTIxOTU1MjQ3._V1_.jpg">
    </iframe>

    <iframe id="inlineFrameExample"
            title="Inline Frame Example"
            width="768"
            height="512"
            src="https://xkcd.com">
    </iframe>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="red"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="orange"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="yellow"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="green"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="blue"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="purple"/></svg>


    </a-->
    <div id="elements" class="windowbuttons" style="display:none; visibility:hidden;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8 2.125" height="16pt">
            <g id="button-delete" transform="scale(0.125 0.125) translate(1 1)">
                <rect x="0" y="0" width="16" height="16" fill="RGB(100,100,100)" stroke="none" />
                <path d="M 1,1 l 3,0 4,4 4,-4 3,0
	     0,3 -4,4 4,4 0,3
	     -3,0 -4,-4 -4,4 -3,0
	     0,-3 4,-4 -4,-4 0,-3 z" fill="RGB(170,170,170)" stroke="none" />
            </g>

            <g id="button-fullscreen" transform="scale(0.125 0.125) translate(21 1)">
                <rect x="0" y="0" width="16" height="16" fill="RGB(100,100,100)" stroke="none" />
                <path d="M  1, 1 l 3,0 1.5,1.5 -3,0 0,3 -1.5,-1.5 0,-3 z
	     M 15, 1 l -3,0 -1.5,1.5 3,0 0,3 1.5,-1.5 0,-3 z
	     M 15,15 l -3,0 -1.5,-1.5 3,0 0,-3 1.5,1.5 0,3 z
	     M  1,15 l 3,0 1.5,-1.5 -3,0 0,-3 -1.5,1.5 0,3 z
	     M  4, 4 l 2,0 1,1 -2,0 0,2 -1,-1 0,-2 z
	     M 12, 4 l -2,0 -1,1 2,0 0,2 1,-1 0,-2 z
	     M 12,12 l -2,0 -1,-1 2,0 0,-2 1,1 0,2 z
	     M  4,12 l 2,0 1,-1 -2,0 0,-2 -1,1 0,2 z
	     " fill="RGB(170,170,170)" stroke="none" />
            </g>

            <g id="button-collapse" transform="scale(0.125 0.125) translate(41 1)">
                <rect x="0" y="0" width="16" height="16" fill="RGB(100,100,100)" stroke="none" />
                <circle cx="8" cy="8" r="5.375" stroke="RGB(170,170,170)" stroke-width="2.75" fill="none" />
            </g>

        </svg>



    </div>
    <script>
        //console.log("test");
        document.body.style.overflow = 'hidden';
        var svg = document.getElementById("svg_bg");
        let svg_bg = svg.getElementById("bg");
        let svg_viewmat = svg.getElementById("viewmatrix");
        let svg_mousePath = svg.getElementById("mousePath");
        var svg_viewbox_size = 65536;
        let time = () => (current_time === undefined) ? 0 : current_time;
        class vec2 {
            constructor(x, y) {
                if (typeof x === "object") {
                    y = x.y;
                    x = x.x;
                }
                this.x = x;
                this.y = y;
            }
            plus(o) {
                return new vec2(this.x + o.x, this.y + o.y);
            }
            minus(o) {
                return new vec2(this.x - o.x, this.y - o.y);
            }
            times(o) {
                return new vec2(this.x * o.x, this.y * o.y);
            }
            div(o) {
                return new vec2(this.x / o.x, this.y / o.y);
            }
            dot(o) {
                return this.x * o.x + this.y * o.y
            }
            rot(a) {
                let c = Math.cos(a);
                let s = Math.sin(a);
                return new vec2(this.x * c - this.y * s, this.x * s + this.y * c);
            }
            rot90() {
                return new vec2(this.y, -this.x);
            }
            unrot90() {
                return new vec2(-this.y, this.x);
            }
            cross(o) {
                return this.x * o.y - this.y * o.x
            }
            scale(s) {
                return new vec2(this.x * s, this.y * s);
            }
            unscale(s) {
                return new vec2(this.x / s, this.y / s);
            }
            normed(s = 1) {
                return this.scale(s / this.mag());
            }
            mag2() {
                return this.dot(this);
            }
            mag() {
                return Math.hypot(this.x, this.y);
            }
            ang() {
                return Math.atan2(this.y, this.x);
            }
            pang() {
                if (this.x == 0 && this.y == 0) {
                    return 0;
                }
                let p = this.x / (Math.abs(this.x) + Math.abs(this.y));
                return this.y < 0 ? p - 1 : 1 - p;
            }
            map(f) {
                return new vec2(f(this.x), f(this.y));
            }

            cadd(o) {
                return this.plus(o);
            }
            csub(o) {
                return this.minus(o);
            }
            cneg(o) {
                return new vec2(-this.x, -this.y);
            }
            cmult(o) {
                return new vec2(this.x * o.x - this.y * o.y, this.y * o.x + this.x * o.y);
            }
            caamult(o) {
                //angle averaging multiply?
                let s = this.plus(o);
                return s.scale(this.cmult(o).mag() / s.mag());
            }
            cconj() {
                return new vec2(this.x, -this.y);
            }
            crecip() {
                // 1/(a+bi) = (a-bi)/mag2
                return this.cconj().unscale(this.mag2());
            }
            cdiv(o) {
                return this.cmult(o.crecip());
            }
            cpow(o) {
                let l = this.clog();
                if (typeof o === "number") {
                    l = l.scale(o);
                } else {
                    l = l.cmult(o);
                }
                if (l.hasNaN()) {
                    return new vec2(0, 0);
                }
                return l.cexp();
            }
            ipow(n) {
                if (n < 0) {
                    return this.crecip().ipow(-n);
                }
                if (n == 0) {
                    return new vec2(1, 0);
                }
                if (n == 1) {
                    return this;
                }
                let c = this.ipow(n >> 1);
                c = c.cmult(c);
                if (n & 1) {
                    return c.cmult(this);
                }
                return c;
            }
            hasNaN() {
                return isNaN(this.x) || isNaN(this.y);
            }
            isFinite() {
                return isFinite(this.x) && isFinite(this.y);
            }
            cexp() {
                let m = Math.exp(this.x);
                let i = Math.sin(this.y);
                let r = Math.cos(this.y);
                return new vec2(m * r, m * i);
            }
            clog() {
                let r = Math.log(this.mag2()) / 2; //no sqrt because log rules
                let i = Math.atan2(this.y, this.x);
                return new vec2(r, i);
            }

            str() {
                return this.x + "," + this.y;
            }
            sqrt() {
                //https://www.johndcook.com/blog/2020/06/09/complex-square-root/
                let l = this.mag();
                let u = Math.sqrt((l + this.x) / 2);
                let v = Math.sign(this.y) * Math.sqrt((l - this.x) / 2);
                return new vec2(u, v);
            }
            lerpto(o, t) {
                return new vec2(lerp(this.x, o.x, t), lerp(this.y, o.y, t));
            }
            ctostring() {
                return ("" + this.y).startsWith("-") ? this.x + "-i" + (-this.y) : this.x + "+i" + this.y;
            }
        }

        function lerp(a, b, t) {
            return a * (1 - t) + b * t;
        }

        var mousePos = new vec2(0, 0);
        var mousePath = "";

        var zoom = new vec2(4, 0); //bigger is further out
        var pan = new vec2(0, 0);

        var zoomTo = new vec2(4, 0);
        var panTo = new vec2(0, 0);
        var autopilotReferenceFrame = undefined;
        var autopilotSpeed = 0;

        function skipAutopilot() {
            zoom = zoomTo
            pan = autopilotReferenceFrame ? autopilotReferenceFrame.pos.plus(panTo) : panTo;
        }

        var settings = {
            zoomSpeed: 0.001,
            panSpeed: 1,
            zoomContentExp: 0.5,
            gestureZoomSpeed: 0.01,
            gestureRotateSpeed: Math.PI / 180,
            scroll: ('GestureEvent' in window) ? "pan" : "zoom",
            maxLines: 512,
            nodeModeKey: "Shift", //"CapsLock",
            nodeModeTrigger: "down", //"toggle"
            renderStepSize: 1, //0.25,
            renderWidthMult: 0.25, //1,
            renderSteps: 16, //64,
            renderDChar: "L",

            rotateModifier: "Alt",
            rotateModifierSpeed: Math.PI / 180 / 36,

            iterations: 256,

            //autopilotRF_Pscale:1,
            autopilotRF_Iscale: 0.5,
            //autopilotRF_Dscale:0.1,
            autopilotSpeed: 0.1,
            autopilotMaxSpeed: 0.1,

            buttonGraphics: {
                hover: ["RGB(100,100,100)", "RGB(200,200,255)"],
                click: ["RGB(70,70,70)", "RGB(100,100,100)"],
                initial: ["none", "RGB(170,170,170)"]
            },

            maxDist: 4,
            orbitStepRate: 2,

        }

        function setRenderQuality(n) {
            let q = 1 / n;
            let f = settings.renderStepSize / q;
            settings.renderStepSize = q;
            settings.renderWidthMult *= f;
            settings.renderSteps *= f;
        }
        setRenderQuality(getQuality());

        function setRenderLength(l) {
            let f = settings.renderStepSize * settings.renderSteps / l;
            //settings.renderStepSize /= f;
            //settings.renderWidthMult *= f;
            settings.renderSteps /= f;
        }
        setRenderLength(getLength());

        function windowScaleAndOffset() {
            let svgbb = svg.getBoundingClientRect();
            let s = Math.min(svgbb.width, svgbb.height); //Math.hypot(window.innerHeight,window.innerWidth)/2**.5;
            let off = svgbb.width < svgbb.height ? svgbb.right : svgbb.bottom;
            return {
                s: s,
                o: new vec2(-(off - svgbb.right) / 2, -(off - svgbb.bottom) / 2)
            }
        }

        function toZ(c) {
            let {
                s,
                o
            } = windowScaleAndOffset();
            return c.minus(o).unscale(s).minus(new vec2(.5, .5)).scale(2).cmult(zoom).cadd(pan);
        }

        function toS(c) {
            let {
                s,
                o
            } = windowScaleAndOffset();
            return c.unscale(s).scale(2);
        }

        function toDZ(c) {
            let {
                s,
                o
            } = windowScaleAndOffset();
            return c.unscale(s).scale(2).cmult(zoom);
        }

        function fromZ(z) {
            let {
                s,
                o
            } = windowScaleAndOffset();
            return z.csub(pan).cdiv(zoom).unscale(2).plus(new vec2(.5, .5)).scale(s).plus(o);
        }

        function fromZtoUV(z) {
            return z.csub(pan).cdiv(zoom).unscale(2).plus(new vec2(.5, .5));
        }
        var SVGzoom = 8192;
        var SVGpan = new vec2(0, 0);
        let recenterThreshold = 0.01;
        let rezoomThreshold = 0.1;
        let rezoomFactor = 8192;
        let old_rotation = 0;

        function updateViewbox() {
            //let lc = toSVG(toZ(new vec2(0,0)));
            let zm = zoom.mag();
            let lc = toSVG(new vec2(-zm, -zm).plus(pan));
            let d = zm * 2 * SVGzoom;
            let r = zoom.ang();
            //let rotCenter = fromZ(pan);// = {let s = window.innerWidth; return new vec2(.5*s,.5*s);}

            let recalc = false;
            if (d < Math.abs(recenterThreshold * lc.x) || d < Math.abs(recenterThreshold * lc.y)) {
                let oldPan = SVGpan;
                SVGpan = pan.scale(1);
                lc = toSVG(toZ(new vec2(0, 0)));
                //console.log("recentering...");
                recalc = true;
            }
            if (d < rezoomThreshold || d > rezoomFactor / rezoomThreshold) {
                SVGzoom *= rezoomFactor / d;
                //console.log("rezooming...");
                recalc = true;
            }
            if (recalc) {
                recalc_svg();
            }

            let c = toSVG(pan); //center of rotation
            //where it ends up if you do the rotation about SVGpan
            let rc = c.cmult(zoom.unscale(zm).cconj());
            //
            lc = lc.plus(rc.minus(c));

            svg.setAttribute("viewBox", lc.x + " " + lc.y + " " + d + " " + d);


            if (r !== old_rotation) {
                old_rotation = r;
                svg_viewmat.setAttribute("transform", "rotate(" + (-r * 180 / Math.PI) + ")");
                //svg_viewmat.setAttribute("transform","rotate("+(-r*180/Math.PI)+" "+c.x+" "+c.y+")");
            }


            return

            // the below has the issue of low-res svg when changing the matrix in firefox
            svg.setAttribute("viewBox", (-svg_viewbox_size / 2) + " " + (-svg_viewbox_size / 2) + " " + svg_viewbox_size + " " + svg_viewbox_size);
            // z = bal(uv)*zoom+pan
            // svg = (z-svgpan)*svgzoom
            // want matrix to go svg -> bal(uv)*65536
            // bal(uv)*65536 = 65536*(z-pan)/zoom = 65536*(svg/svgzoom-svgpan-pan)/zoom
            // d/dsvg = 65536/svgzoom/zoom
            // f(0) = -65536*(svgpan+pan)/zoom
            let t = zoom.crecip().scale(svg_viewbox_size / SVGzoom / 2);
            let p = pan.minus(SVGpan).scale(-svg_viewbox_size / 2).cdiv(zoom);

            svg_viewmat.setAttribute("transform", "matrix(" + t.x + " " + (t.y) + " " + (-t.y) + " " + (t.x) + " " + (p.x) + " " + (p.y) + ")");
            //svg_bg.setAttribute("transform","matrix("+z.x+" "+(-z.y)+" "+(z.y)+" "+(z.x)+" "+SVGpan.x+" "+SVGpan.y+")");

        }

        function toSVG(coords) {
            return coords.minus(SVGpan).scale(SVGzoom);
        }

        function recalc_svg() {
            //todo
            //placeholder:
            let node = svg_bg;
            while (node.firstChild) {
                node.removeChild(node.lastChild);
            }
        }





        document.getElementById("body").addEventListener("mousemove", (event) => {
            mousePos.x = event.pageX;
            mousePos.y = event.pageY;
            mousePath = "";
        }, false);
        document.getElementById("body").addEventListener("mouseclick", (event) => {
            mousePos.x = event.pageX;
            mousePos.y = event.pageY;
            /*let p = toZ(mousePos);
            zoom = zoom.unscale(2);
            pan = p;*/
        }, false);

        function mand_step(z, c) {
            return z.cmult(z).cadd(c);
        }
        //function mand_step(z,c){return z.cpow(new vec2(time()/8/120/10+1,0)).cadd(c);}
        //function mand_step(z,c){return z.cmult(z).cadd(z.x==0&&z.y==0?c:c.cdiv(z));}
        //function mand_step(z,c){return z.cmult(z).cadd(c).map(Math.abs);}

        function mand_unstep(z, c) {
            return z.csub(c).sqrt();
        }

        function mand_i(z, iters = 16) {
            let c = z;
            for (let i = 0; i < iters; i++) {
                if (z.mag2() > 4) {
                    return i;
                }
                z = mand_step(z, c);
            }
            return (z.mag2() > 4) ? iters : iters + 1;
        }

        function mandelbrott_dist(iters, c, z) {
            if (z === undefined) {
                z = new vec2(0, 0);
            }
            let pz = z;
            for (let i = 0; i < iters; i++) {
                if (z.mag2() > 4) {
                    let zm = z.mag();
                    let pzm = pz.mag();
                    return i + (2 - pzm) / (zm - pzm);
                }
                pz = z;
                z = mand_step(z, c);
            }
            return iters;
        }

        function mandelbrott_dist(iters, c, z) {
            let bailout = 1e8; //large so z^2+c -> z^2
            if (z === undefined) {
                z = new vec2(0, 0);
            }
            let pz = z;
            for (let i = 0; i < iters; i++) {
                if (z.mag2() > bailout) {
                    //pz^2 = z
                    //pz^(2^?) = b
                    //ln(pz)2^?=ln(b)
                    //ln(ln(pz))+ln(2)*?=ln(ln(b))
                    let g = Math.log2(Math.log(bailout));
                    let llz = Math.log2(Math.log2(z.mag2()) / 2);
                    return i - llz;
                }
                pz = z;
                z = mand_step(z, c);
            }
            return iters;
        }

        function mandelbrott_grad(iters, c, z) {
            let bailout = 1e8; //large so z^2+c -> z^2
            if (z === undefined) {
                z = new vec2(0, 0);
            }
            let dz = new vec2(1, 0);
            for (let i = 0; i < iters; i++) {
                if (z.mag2() > bailout) {
                    //pz^2 = z
                    //pz^(2^?) = b
                    //ln(pz)2^?=ln(b)
                    //ln(ln(pz))+ln(2)*?=ln(ln(b))
                    return dz;
                    let llz = Math.log2(Math.log2(z.mag2()) / 2);
                    return i - llz;
                }
                z = mand_step(z, c);
                dz = dz.cmult(z.scale(2));
            }
            return new vec2(0, 0);
        }

        function mandGrad(maxIters, c, z) {
            //return mandelbrott_grad(maxIters,c,z);
            let e = 1e-10;
            let d = mandelbrott_dist(maxIters, c, z);
            return new vec2(
                mandelbrott_dist(maxIters, c.plus(new vec2(e, 0)), z) - d,
                mandelbrott_dist(maxIters, c.plus(new vec2(0, e)), z) - d
            ).unscale(e);

            //let re = 1.00000001;
            //let e = 1e-100;
            //if (z === undefined) { z = c;}
            //let d = mandelbrott_dist(maxIters,c,z);
            //let f = (v) => (Math.abs(v)<e?v+e:v*re);
            //let fz = new vec2(f(z.x),f(z.y));
            //return new vec2(
            //    mandelbrott_dist(maxIters,c,new vec2(fz.x,z.y))-d,
            //    mandelbrott_dist(maxIters,c,new vec2(z.x,fz.y))-d
            //    ).div(fz.minus(z));
        }

        function gradzr(f, z, epsilon = 1e-6) {
            let r = f(z);
            return new vec2(f(z.plus(new vec2(epsilon, 0))) - r, f(z.plus(new vec2(0, epsilon))) - r).unscale(epsilon);
        }


        function* trace_circle(iters, z0, step) {
            if (step === undefined) {
                step = 0.5;
            }
            let level = mandelbrott_dist(iters, z0);
            let z = z0;
            while (true) {
                yield z;
                let vz = mandelbrott_dist(iters, z);
                let gz = mandGrad(iters, z);
                z = z.plus(gz.cmult(new vec2(level - vz, step).unscale(gz.mag2())));
            }
        }

        function mcol(iters, z) {
            let i = mandelbrott_dist(iters, z);
            if (i >= iters) {
                i = findInfimum(iters, z);
                //i = findPeriod(z);
                return scol(i.i * 123 + 2, (1 - nodeMode_v), 128, 32 + (1 - nodeMode_v) * 48);
            } else {
                return scol(i);
            }
        }

        function col(i, r = undefined, c = 128, s = 127) {
            if (r === undefined) {
                r = nodeMode_v
            }
            let rgb = [c - s * Math.cos(i / 2 ** .9), c - s * Math.cos(i / 3 ** .9), c - s * Math.cos(i / 5 ** .9)];
            let y = 0.17697 * rgb[0] + 0.81240 * rgb[1] + 0.01063 * rgb[2];
            return [lerp(rgb[0], y, r), lerp(rgb[1], y, r), lerp(rgb[2], y, r)];
        }

        function scol(i, r = undefined, c = 128, s = 127) {
            c = col(i, r, c, s);
            return "RGB(" + Math.round(c[0]) + "," + Math.round(c[1]) + "," + Math.round(c[2]) + ")";
        }


        //let l = document.getElementById("link");
        //l.style.position="absolute";
        //l.style.left="100px";
        //l.style.top="100px";


        function outlineMand(start, step, iters) {
            iters = iters === undefined ? 256 : iters;
            step = step === undefined ? 0.1 : step;
            let a0 = start.pang();
            let path = "M " + toSVG(start).str() + "\nL ";
            let pz = start;
            let maxlen = 1 << 15;
            let minD2 = 0.25 / 200 / 200;
            for (let z of trace_circle(iters, start, step)) {
                //if (z.minus(pz).mag2() < minD2){ continue;}
                if (z.pang() <= a0 && pz.pang() > a0) {
                    break;
                }
                maxlen--;
                if (maxlen <= 0) {
                    break;
                }
                path += toSVG(z).str() + " ";
                pz = z;
            }
            return path;
        }

        function addPath(path, stroke, fill) {
            if (stroke === undefined) {
                stroke = "red"
            }
            if (fill === undefined) {
                stroke = "none"
            }
            let pathn = document.createElementNS("http://www.w3.org/2000/svg", "path");
            pathn.setAttribute("fill", fill);
            pathn.setAttribute("stroke", stroke);
            pathn.setAttribute("d", path);
            svg.appendChild(pathn);
            return pathn;
        }

        function* iter() {
            for (let x = 8; x > 0.3; x *= 1 - 1 / 8) {
                let pathn = document.createElementNS("http://www.w3.org/2000/svg", "path");
                //pathn.setAttribute("fill",scol(mandelbrott_dist(1024,new vec2(x,0))));
                pathn.setAttribute("fill", "none");
                pathn.setAttribute("stroke", scol(mandelbrott_dist(1024, new vec2(x, 0))));
                pathn.setAttribute("stroke-width", "" + (SVGzoom * 0.01));
                pathn.setAttribute("d", "");
                svg.children[1].appendChild(pathn);
                let start = new vec2(x, 0);
                let a0 = start.pang();
                let l = (m) => m;
                let path = "M " + toSVG(l(start)).str() + "\nL ";
                let pz = start;
                let maxlen = 1 << 12;
                let minD2 = 0.01 / 200 / 200;
                for (let z of trace_circle(1024, start, 0.1)) {

                    if (z.pang() <= a0 && pz.pang() > a0) {
                        break;
                    }
                    maxlen--;
                    if (maxlen <= 0) {
                        pathn.setAttribute("d", path + " z");
                        yield;
                        maxlen = 1 << 12;
                    }
                    if (z.minus(pz).mag2() < minD2) {
                        continue;
                    }
                    path += toSVG(l(z)).str() + " ";
                    pz = z;
                }
                pathn.setAttribute("d", path + " z");
                yield;
            }
        }






        function windowify(title, content, pos, scale, iscale, link) {
            let odiv = document.createElement('div');
            let div = document.createElement('div');
            let buttons = document.getElementById("elements").children[0];
            let w = buttons.cloneNode(true);

            // Create a header container for buttons and title input
            let headerContainer = document.createElement('div');
            headerContainer.style.display = 'flex';
            headerContainer.style.justifyContent = 'space-between';
            headerContainer.style.alignItems = 'center';
            headerContainer.appendChild(w);

            div.appendChild(headerContainer);
            odiv.appendChild(div);

            let innerContent = document.createElement('div');
            innerContent.className = 'content';
            for (let c of content) {
                innerContent.appendChild(c);
            }
            div.appendChild(innerContent);


            odiv.setAttribute("data-init", "window");
            div.setAttribute("class", "window");

            div.addEventListener('click', (event) => {
                event.stopPropagation();
                if (event.altKey) {
                    div.classList.toggle('selected');
                }
            });

            // Add the title input to the header container
            let titleInput = document.createElement('input');
            titleInput.setAttribute('type', 'text');
            titleInput.setAttribute('value', title);
            titleInput.className = 'title-input';
            headerContainer.appendChild(titleInput);

            // Add resize container and handle
            let resizeContainer = document.createElement('div');
            resizeContainer.className = 'resize-container';
            div.appendChild(resizeContainer);

            let resizeHandle = document.createElement('div');
            resizeHandle.className = 'resize-handle';
            resizeContainer.appendChild(resizeHandle);

            let node = new Node(pos, odiv, scale, iscale || new vec2(1, 1));
            div.win = node; // Add this line to store the node object in the div element
            setResizeEventListeners(resizeHandle, node);
            observeContentResize(innerContent, div);
            div.win = node;
            return rewindowify(node);
        }

        function setResizeEventListeners(resizeHandle, node) {
            const inverse2DMatrix = (matrix) => {
                const det = matrix[0] * matrix[3] - matrix[1] * matrix[2];
                if (det === 0) {
                    return null;
                }
                const invDet = 1 / det;
                return [
                    matrix[3] * invDet,
                    -matrix[1] * invDet,
                    -matrix[2] * invDet,
                    matrix[0] * invDet,
                ];
            };

            const getDivInverseTransformMatrix = (div) => {
                const transform = window.getComputedStyle(div).transform;
                if (transform === 'none') {
                    return [1, 0, 0, 1];
                }
                const matrix = transform
                    .split('(')[1]
                    .split(')')[0]
                    .split(',')
                    .map(parseFloat)
                    .slice(0, 4);
                return inverse2DMatrix(matrix);
            };

            let windowDiv = resizeHandle.parentElement.parentElement;
            let startX;
            let startY;
            let startWidth;
            let startHeight;

            let isMouseMoving = false;

            function extractScalingFactors(element) {
                const rect = element.getBoundingClientRect();
                const style = window.getComputedStyle(element);
                const width = parseFloat(style.width);
                const height = parseFloat(style.height);

                if (width === 0 || height === 0) {
                    return {
                        scaleX: 1,
                        scaleY: 1
                    };
                }

                const scaleX = rect.width / width;
                const scaleY = rect.height / height;

                return {
                    scaleX,
                    scaleY
                };
            }

            const handleMouseMove = (event) => {
                if (!event.buttons) {
                    handleMouseUp();
                    return;
                }
                isMouseMoving = true;

                // Extract scaling factors from the accumulated transform matrix
                const {
                    scaleX,
                    scaleY
                } = extractScalingFactors(windowDiv);

                // Calculate the change in position of the mouse considering the scaling factors
                const dx = 2 * (event.pageX - startX) / scaleX;
                const dy = 2 * (event.pageY - startY) / scaleY;

                const content = windowDiv.querySelector('.content');
                const minWidth = content ? content.offsetWidth + 0 : 100;
                const minHeight = content ? content.offsetHeight + 35 : 100;
                const newWidth = Math.max(startWidth + dx, minWidth);
                const newHeight = Math.max(startHeight + dy, minHeight);
                windowDiv.style.width = `${newWidth}px`;
                windowDiv.style.height = `${newHeight}px`;
            };

            const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
                isMouseMoving = false;
            };

            resizeHandle.addEventListener('mousedown', (event) => {
                event.preventDefault();
                event.stopPropagation();
                startX = event.pageX;
                startY = event.pageY;
                startWidth = parseInt(document.defaultView.getComputedStyle(windowDiv).width, 10);
                startHeight = parseInt(document.defaultView.getComputedStyle(windowDiv).height, 10);

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });

            resizeHandle.addEventListener('mouseenter', () => {
                document.body.style.cursor = 'nwse-resize';
            });

            resizeHandle.addEventListener('mouseleave', () => {
                if (!isMouseMoving) {
                    document.body.style.cursor = 'auto';
                }
            });
        }






        function rewindowify(node) {
            node.push_extra("window");
            let w = node.content;


            let del = w.querySelector("#button-delete");
            let fs = w.querySelector("#button-fullscreen");
            let col = w.querySelector("#button-collapse");

            function set(e, v, s = "fill") {
                e.children[0].setAttribute("fill", settings.buttonGraphics[v][0]);
                e.children[1].setAttribute(s, settings.buttonGraphics[v][1]);
            }

            function ui(e, cb = (() => { }), s = "fill") {
                e.onmouseenter = (ev) => {
                    set(e, "hover", s);
                }
                e.onmouseleave = (ev) => {
                    set(e, "initial", s);
                    e.ready = false;
                }
                e.onmousedown = (ev) => {
                    set(e, "click", s);
                    e.ready = true;
                    cancel(ev);
                }
                e.onmouseup = (ev) => {
                    set(e, "initial", s);
                    cancel(ev);
                    if (e.ready) {
                        cb(ev);
                    }
                }
                e.onmouseleave();
            }
            ui(del, node.remove.bind(node));
            ui(fs, (() => {
                node.zoom_to_fit();
                zoomTo = zoomTo.scale(1.0625);
                autopilotSpeed = settings.autopilotSpeed;
            }));
            ui(col, (() => { }), "stroke");

            return node;
        }






        function put(e, p, s = 1) {
            let svgbb = svg.getBoundingClientRect();
            e.style.position = "absolute";
            e.style.transform = "scale(" + s + "," + s + ")";
            p = fromZtoUV(p);
            if (p.minus(new vec2(0.5, 0.5)).mag2() > 16) {
                e.style.display = "none";
            } else {
                e.style.display = "initial";
            }
            let w = Math.min(svgbb.width, svgbb.height);
            let off = svgbb.width < svgbb.height ? svgbb.right : svgbb.bottom;
            p.x = w * p.x - (off - svgbb.right) / 2;
            p.y = w * p.y - (off - svgbb.bottom) / 2;
            let bb = e.getBoundingClientRect();
            p = p.minus(new vec2(bb.width, bb.height).scale(0.5 / s));
            e.style.left = p.x + "px";
            e.style.top = p.y + "px";


            //e.style['margin-top'] = "-"+(e.offsetHeight/2)+"px";//"-50%";
            //e.style['margin-left'] = "-"+(e.offsetWidth/2)+"px";//"-50%";
            //e.style['vertical-align']= 'middle';
            //e.style['text-align']= 'center';

        }

        const NodeExtensions = {
            "window": (node, a) => {
                rewindowify(node);
            },
            "textarea": (node, o) => {
                let e = node.content;
                for (let w of o.p) {
                    e = e.children[w];
                }
                let p = o.p;
                e.value = o.v;
                node.push_extra_cb((n) => {
                    return {
                        f: "textarea",
                        a: {
                            p: p,
                            v: e.value
                        }
                    };
                });
            },
        }


        var movingNode = undefined;
        let prevNode = undefined;
        var NodeUUID = 0;
        var nodeMap = {};

        function nextUUID() {
            while (nodeMap[NodeUUID] !== undefined) {
                NodeUUID++;
            }
            return NodeUUID;
        }
        class Node {
            constructor(p, thing, scale = 1, intrinsicScale = 1) {
                this.anchor = new vec2(0, 0);
                this.anchorForce = 0;
                this.mouseAnchor = new vec2(0, 0);
                this.edges = [];
                this.createdAt = new Date().toISOString();
                this.init = (nodeMap) => { };
                if (p === undefined) {
                    let n = thing;
                    let o = JSON.parse(n.dataset.node_json)
                    for (const k of ['anchor', 'mouseAnchor', 'vel', 'pos', 'force']) {
                        o[k] = new vec2(o[k]);
                    }
                    for (const k in o) {
                        this[k] = o[k];
                    }
                    this.save_extras = [];
                    this.content = thing;
                    if (n.dataset.node_extras) {
                        o = JSON.parse(n.dataset.node_extras);
                        for (const e of o) {
                            NodeExtensions[e.f](this, e.a);
                        }
                    }
                    this.attach();
                    this.content.setAttribute("data-uuid", this.uuid);
                    if (n.dataset.edges !== undefined) {
                        let es = JSON.parse(n.dataset.edges);
                        this.init = ((nodeMap) => {
                            for (let e of es) {
                                edgeFromJSON(e, nodeMap);
                            }
                        }).bind(this);
                    }
                    return;
                } else {
                    this.uuid = nextUUID();
                }
                this.uuid = "" + this.uuid;

                this.pos = p;
                this.scale = scale;
                this.intrinsicScale = intrinsicScale;

                this.content = thing;

                this.vel = new vec2(0, 0);
                this.force = new vec2(0, 0);
                this.followingMouse = 0;

                this.removed = false;

                this.content.setAttribute("data-uuid", this.uuid);
                this.attach();
                this.save_extras = [];
            }
            attach() {
                let div = this.content;
                let node = this;
                div.onclick = node.onclick.bind(node);
                div.ondblclick = node.ondblclick.bind(node);
                div.onmousedown = node.onmousedown.bind(node);
                div.onmouseup = node.onmouseup.bind(node);
                div.onmousemove = node.onmousemove.bind(node);
                div.onwheel = node.onwheel.bind(node);
            }
            json() {
                return JSON.stringify(this, (k, v) => {
                    if (k === "content" || k === "edges" || k === "save_extras") {
                        return undefined;
                    }
                    return v;
                });
            }
            push_extra_cb(f) {
                this.save_extras.push(f);
            }
            push_extra(func_name, args = undefined) {
                this.save_extras.push({
                    f: func_name,
                    a: args
                });
            }
            draw() {
                put(this.content, this.pos, this.intrinsicScale * this.scale * (zoom.mag2() ** -settings.zoomContentExp));
                this.content.setAttribute("data-node_json", this.json());
                let se = [];
                for (let e of this.save_extras) {
                    se.push(typeof e === "function" ? e(this) : e);
                }
                this.content.setAttribute("data-node_extras", JSON.stringify(se));

                //this.content.setAttribute("data-vy",this.vel.y);
                //this.content.setAttribute("data-x",this.pos.x);

            }
            zoom_to_fit(margin = 1) {
                let bb = this.content.getBoundingClientRect();
                let svgbb = svg.getBoundingClientRect();
                let so = windowScaleAndOffset();
                let aspect = svgbb.width / svgbb.height;
                let scale = bb.height * aspect > bb.width ? svgbb.height / (margin * bb.height) : svgbb.width / (margin * bb.width);
                this.zoom_by(1 / scale);
            }
            zoom_by(s = 1) {
                panTo = new vec2(0, 0); //this.pos;
                let gz = ((s) ** (-1 / settings.zoomContentExp));
                zoomTo = zoom.unscale(gz ** 0.5);
                autopilotReferenceFrame = this;
                panToI = new vec2(0, 0);
            }
            zoom_to(s = 1) {
                panTo = new vec2(0, 0); //this.pos;
                let gz = zoom.mag2() * ((this.scale * s) ** (-1 / settings.zoomContentExp));
                zoomTo = zoom.unscale(gz ** 0.5);
                autopilotReferenceFrame = this;
                panToI = new vec2(0, 0);
            }

            addEdge(edge) {
                this.edges.push(edge);
                this.updateEdgeData();
            }
            updateEdgeData() {
                let es = JSON.stringify(this.edges.map((e) => e.dataObj()));
                this.content.setAttribute("data-edges", es);
            }


            step(dt) {
                if (dt === undefined || isNaN(dt)) {
                    dt = 0;
                } else {
                    if (dt > 1) {
                        dt = 1;
                    }
                }
                if (!this.followingMouse) {
                    this.pos = this.pos.plus(this.vel.scale(dt / 2));
                    this.vel = this.vel.plus(this.force.scale(dt));
                    this.pos = this.pos.plus(this.vel.scale(dt / 2));
                    this.force = this.vel.scale(-Math.min(this.vel.mag() + 0.4 + this.anchorForce, 1 / (dt + 1e-300)));
                } else {
                    this.vel = new vec2(0, 0);
                    this.force = new vec2(0, 0);
                }
                let g = mandGrad(settings.iterations, this.pos);
                //g.y *= -1; //why?
                this.force = this.force.plus(g.unscale((g.mag2() + 1e-10) * 300));
                this.force = this.force.plus(this.anchor.minus(this.pos).scale(this.anchorForce));
                //let d = toZ(mousePos).minus(this.pos);
                //this.force = this.force.plus(d.scale(this.followingMouse/(d.mag2()+1)));
                if (this.followingMouse) {
                    let p = toZ(mousePos).minus(this.mouseAnchor);
                    this.vel = p.minus(this.pos).unscale(nodeMode ? 1 : dt);
                    this.pos = p;
                    this.anchor = this.pos;
                }
                //this.force = this.force.plus((new vec2(-.1,-1.3)).minus(this.pos).scale(0.1));
                this.draw();
            }
            searchStrings() {
                function* search(e) {
                    yield e.textContent;
                    if (e.value)
                        yield e.value;
                    for (let c of e.children) {
                        yield* search(c);
                    }
                }
                return search(this.content);
            }
            onclick(event) {

            }
            toggleWindowAnchored(anchored) {
                if (anchored) {
                    this.content.classList.add("window-anchored");
                } else {
                    this.content.classList.remove("window-anchored");
                }
            }
            ondblclick(event) {
                this.anchor = this.pos;
                this.anchorForce = 1 - this.anchorForce;
                this.toggleWindowAnchored(this.anchorForce === 1);
                cancel(event);
            }
            onmousedown(event) {
                this.mouseAnchor = toZ(new vec2(event.clientX, event.clientY)).minus(this.pos);
                this.followingMouse = 1;
                movingNode = this;
                if (nodeMode) {
                    if (prevNode === undefined) {
                        prevNode = this;
                    } else {
                        connect(this, prevNode, this.pos.minus(prevNode.pos).mag() / 2);
                        prevNode = undefined;
                    }
                } else {

                }
                cancel(event);
            }
            onmouseup(event) {
                this.followingMouse = 0;
                if (this === movingNode) {
                    movingNode = undefined;
                }
                cancel(event);
            }
            onmousemove(event) {
                if (this.followingMouse) {
                    prevNode = undefined;
                }
                /*if (this.followingMouse){
                this.pos = this.pos.plus(toDZ(new vec2(event.movementX,event.movementY)));
                this.draw()
                //cancel(event);
                }*/
            }
            onwheel(event) {
                if (nodeMode) {
                    let amount = Math.exp(event.wheelDelta * -settings.zoomSpeed);
                    let targetWindow = event.target.closest('.window');

                    // Check if the event target is a selected window
                    if (targetWindow && targetWindow.classList.contains('selected')) {
                        // Get all selected windows
                        const selectedWindows = document.querySelectorAll('.window.selected');

                        // Scale all selected windows
                        selectedWindows.forEach((selectedWindow) => {
                            let winNode = selectedWindow.win;

                            // Modify the scaling logic for selected windows here
                            winNode.scale *= amount;
                            winNode.pos = winNode.pos.lerpto(toZ(mousePos), 1 - amount);

                            // Scale edges connected to the selected window
                            winNode.edges.forEach((edge) => {
                                edge.scaleEdge(amount);
                            });
                        });
                    } else {
                        // Scale the current window
                        this.scale *= amount;
                        this.pos = this.pos.lerpto(toZ(mousePos), 1 - amount);
                    }

                    cancel(event);
                }
            }
            remove() {
                let dels = [];
                for (let n of nodes) {
                    for (let e of n.edges) {
                        if (e.pts.includes(this)) {
                            dels.push(e);
                        }
                    }
                }
                for (let e of dels) {
                    e.remove();
                }

                let index = nodes.indexOf(this);
                if (index !== -1) {
                    nodes.splice(index, 1);
                }
                if (nodeMap[this.uuid] === this) {
                    delete nodeMap[this.uuid];
                }

                this.removed = true;
                this.content.remove();
            }

        }
        let htmlnodes_parent = document.getElementById("nodes");
        let htmlnodes = htmlnodes_parent.children;
        let htmledges = document.getElementById("edges");

        function edgeFromJSON(o, nodeMap) {
            let pts = o.p.map((k) => nodeMap[k]);
            if (pts.includes(undefined)) {
                console.warn("missing keys", o, nodeMap);
            }
            let e = new Edge(pts, o.l, o.s, o.g);
            pts[0].addEdge(e);
            edges.push(e);
            return e
        }
        class Edge {
            constructor(pts, length = 0.6, strength = 0.1, style = {
                stroke: "red",
                "stroke-width": "0.01",
                fill: "red"
            }) {
                this.pts = pts;
                this.length = length;
                this.strength = strength;
                this.style = style;
                this.html = document.createElementNS("http://www.w3.org/2000/svg", "path");
                for (const [key, value] of Object.entries(style)) {
                    this.html.setAttribute(key, value);
                }
                htmledges.appendChild(this.html);
                this.attach();
            }
            scaleEdge(amount) {
                this.length *= amount;
            }
            dataObj() {
                let o = {};
                o.l = this.length;
                o.s = this.strength;
                o.g = this.style;
                o.p = this.pts.map((n) => n.uuid);
                return o;
            }
            attach() {
                this.html.onwheel = this.onwheel.bind(this);
                this.html.onmouseover = this.onmouseover.bind(this);
                this.html.onmouseout = this.onmouseout.bind(this);
                this.html.ondblclick = this.ondblclick.bind(this);
            }
            stress() {
                let avg = this.center();
                return this.pts.reduce((t, n, i, a) => {
                    return t + n.pos.minus(avg).mag() - this.length;
                }, 0) / (this.length + 1);
            }
            center() {
                return this.pts.reduce((t, n, i, a) => {
                    return t.plus(n.pos);
                }, new vec2(0, 0)).unscale(this.pts.length);
            }
            draw() {
                this.html.setAttribute("stroke", this.mouseIsOver ? "lightskyblue" : this.style.stroke);
                this.html.setAttribute("fill", this.mouseIsOver ? "lightskyblue" : this.style.fill);

                let wscale = this.style['stroke-width'] / (0.5 + this.stress()) * (this.mouseIsOver ? 1.5 : 1.0);
                let path = "M ";
                let c = this.center();
                let validPath = true;

                for (let n of this.pts) {
                    let r = n.scale * wscale;
                    let minusC = n.pos.minus(c);
                    let rotated = minusC.rot90();

                    if (rotated.x !== 0 || rotated.y !== 0) {
                        let left = rotated.normed(r);

                        // Check if coordinates are not NaN
                        if (!isNaN(left.x) && !isNaN(left.y) && !isNaN(n.pos.x) && !isNaN(n.pos.y)) {
                            path += toSVG(n.pos.minus(left)).str();
                            path += " L ";
                            path += toSVG(left.plus(n.pos)).str() + " ";
                        } else {
                            validPath = false;
                            break;
                        }
                    }
                }

                // Check if the first point's coordinates are not NaN
                let firstPoint = this.pts[0].pos.minus(this.pts[0].pos.minus(c).rot90().normed(this.pts[0].scale * wscale));
                if (!isNaN(firstPoint.x) && !isNaN(firstPoint.y)) {
                    path += " " + toSVG(firstPoint).str() + "z";
                } else {
                    validPath = false;
                }

                // Only set the 'd' attribute if the path is valid
                if (validPath) {
                    this.html.setAttribute("d", path);
                }
            }
            step(dt) {
                if (dt === undefined || isNaN(dt)) {
                    dt = 0;
                } else {
                    if (dt > 1) {
                        dt = 1;
                    }
                }
                let avg = this.center();
                for (let n of this.pts) {
                    let d = n.pos.minus(avg);
                    // Calculate the force only if the distance is greater than the desired length
                    if (d.mag() > this.length) {
                        let f = d.scale(1 - this.length / (d.mag() + 1e-300));
                        n.force = n.force.plus(f.scale(-this.strength));
                    }
                }
                this.draw();
            }
            onwheel(event) {
                if (nodeMode) {
                    let amount = Math.exp(event.wheelDelta * -settings.zoomSpeed);
                    this.length *= amount;
                    let avg = this.center();
                    for (let n of this.pts) {
                        n.pos = n.pos.minus(avg).scale(amount).plus(avg);
                    }
                    if (this.pts[0] !== undefined) {
                        this.pts[0].updateEdgeData();
                    }
                    cancel(event);
                }
            }
            onmouseover(event) {
                this.mouseIsOver = true;
            }
            onmouseout(event) {
                this.mouseIsOver = false;
            }
            ondblclick(event) {
                if (nodeMode) {
                    this.remove();
                    cancel(event);
                }
            }
            remove() {
                let index = edges.indexOf(this);
                if (index !== -1) {
                    edges.splice(index, 1);
                }
                index = this.pts[0].edges.indexOf(this);
                if (index !== -1) {
                    this.pts[0].edges.splice(index, 1);
                    this.pts[0].updateEdgeData();
                }
                this.html.remove();
            }
        }

        var nodes = [];
        var edges = [];
        var nodeMode_v = 0;
        var nodeMode = 0;



        for (let n of htmlnodes) {
            //n.setAttribute("onclick","nodeclick("+nodes.length+");");
            console.log(n);
            let node = new Node(undefined, n);
            registernode(node);
            //if (n.dataset.init === "window")
            //    rewindowify(node);
        }
        for (let n of nodes) {
            n.init(nodeMap); //2 pass for connections
        }

        function clearnet() {
            while (edges.length > 0) {
                edges[edges.length - 1].remove();
            }
            while (nodes.length > 0) {
                nodes[nodes.length - 1].remove();
            }
        }

        function loadnet(text, clobber) {
            if (clobber) {
                clearnet();
            }
            let d = document.createElement("div");
            d.innerHTML = text;
            let newNodes = [];
            for (let n of d.children) {
                let node = new Node(undefined, n);
                newNodes.push(node);
                registernode(node);
                if (n.dataset.init === "window")
                    rewindowify(node);
            }
            for (let n of newNodes) {
                htmlnodes_parent.appendChild(n.content);
                n.init(nodeMap); //2 pass for connections
            }


        }

        function searchNodesBy(searchTerm) {
            let keywords = searchTerm.toLowerCase().split(' ');
            let matched = [];
            for (let n of nodes) {
                let numMatches = 0;
                for (let keyword of keywords) {
                    if ([...n.searchStrings()].join().toLowerCase().includes(keyword)) {
                        numMatches++;
                    }
                }
                if (numMatches > 0) {
                    n.content.classList.add("search_matched");
                    n.content.classList.remove("search_nomatch");
                    matched.push({
                        node: n,
                        numMatches: numMatches
                    });
                } else {
                    n.content.classList.remove("search_matched");
                    n.content.classList.add("search_nomatch");
                }
            }
            matched.sort((a, b) => b.numMatches - a.numMatches);
            return matched.map(m => m.node);
        }

        function clearSearch() {
            for (let n of nodes) {
                n.content.classList.remove("search_matched");
                n.content.classList.remove("search_nomatch");
            }
        }

        let inp = document.getElementById("Searchbar")
        inp.addEventListener("input", function () {
            let res = document.getElementById("search-results")
            if (inp.value) {
                res.style.display = "block";
                let ns = searchNodesBy(inp.value);
                let resdiv = res.children[0];
                resdiv.innerHTML = "";
                for (let n of ns) {
                    let c = document.createElement("a")
                    c.appendChild(document.createTextNode(n.uuid + ""));
                    c.addEventListener("click", (function (event) {
                        this.zoom_to();
                        autopilotSpeed = settings.autopilotSpeed;
                    }).bind(n));
                    c.addEventListener("dblclick", (function (event) {
                        this.zoom_to();
                        skipAutopilot();
                        autopilotSpeed = settings.autopilotSpeed;
                    }).bind(n));
                    resdiv.appendChild(c);
                }
            } else {
                res.style.display = "none"
                clearSearch();
            }
        });

        function connect(na, nb, length = 0.2, linkStrength = 0.1, linkStyle = {
            stroke: "none",
            "stroke-width": "0.005",
            fill: "lightcyan",
            opacity: "0.5"
        }) {
            let edge = new Edge([na, nb], length, linkStrength, linkStyle);

            na.addEdge(edge);
            //nb.edges.push(edge);
            //edge.draw();


            edges.push(edge);
            return edge;
        }

        function connectRandom(n) {
            for (let i = 0; i < n; i++) {
                let a = Math.floor(Math.random() * nodes.length);
                let b = Math.floor(Math.random() * nodes.length);
                connect(nodes[a], nodes[b]);
            }
        }

        var gen = iter();

        function frame() {
            gen.next();
            setTimeout(frame, 100);
        }
        const panInput = document.getElementById("pan");
        const zoomInput = document.getElementById("zoom");
        let coordsLive = true;
        const coords = document.getElementById("coordinates");
        panInput.addEventListener("input", (e) => {
            const r = /([+-]?(([0-9]*\.[0-9]*)|([0-9]+))([eE][+-]?[0-9]+)?)\s*,?\s*([+-]?i?(([0-9]*\.[0-9]*)|([0-9]+))([eE][+-]?[0-9]+)?)/;
            const m = panInput.value.match(r);
            coordsLive = false;
            if (m === null) return;
            pan = new vec2(parseFloat(m[0]), parseFloat(m[6].replace(/[iI]/, "")));
        });
        zoomInput.addEventListener("input", (e) => {
            const r = /([+-]?(([0-9]*\.[0-9]*)|([0-9]+))([eE][+-]?[0-9]+)?)/;
            const m = zoomInput.value.match(r);
            coordsLive = false;
            if (m === null) return;
            const z = parseFloat(m);
            if (z !== 0) {
                zoom = zoom.scale(z / zoom.mag());
            }
        });
        for (const k of ["paste", "mousemove", "mousedown", "dblclick", "click"]) {
            panInput.addEventListener(k, (e) => {
                cancel(e);
            })
            zoomInput.addEventListener(k, (e) => {
                cancel(e);
            })
        }
        //frame();
        var mousePathPos;
        var current_time = undefined;
        let regenAmount = 0;
        let regenDebt = 0;
        let avgfps = 0;
        let panToI = new vec2(0, 0);
        let panToI_prev = undefined;

        function nodeStep(time) {
            let autopilot_travelDist = 0;
            let newPan = pan;
            if (autopilotReferenceFrame && autopilotSpeed !== 0) {
                if (panToI_prev === undefined) {
                    panToI_prev = autopilotReferenceFrame.pos.scale(1);
                }
                panToI = panToI.scale(1 - settings.autopilotRF_Iscale).plus(autopilotReferenceFrame.pos.minus(panToI_prev).scale(settings.autopilotRF_Iscale));
                newPan = pan.scale(1 - autopilotSpeed).plus(autopilotReferenceFrame.pos.scale(autopilotSpeed).plus(panToI));
                panToI_prev = autopilotReferenceFrame.pos.scale(1);
            } else {
                newPan = pan.scale(1 - autopilotSpeed).plus(panTo.scale(autopilotSpeed));
                panToI_prev = undefined;
            }
            autopilot_travelDist = pan.minus(newPan).mag() / zoom.mag();
            if (autopilot_travelDist > settings.autopilotMaxSpeed) {
                newPan = pan.plus(newPan.minus(pan).scale(settings.autopilotMaxSpeed / autopilot_travelDist));
                const speedCoeff = Math.tanh(Math.log(settings.autopilotMaxSpeed / autopilot_travelDist + 1e-300) / 10) * 2;
                zoom = zoom.scale(1 - speedCoeff * autopilotSpeed);
                //*Math.log(autopilot_travelDist/settings.autopilotMaxSpeed));
            } else {
                zoom = zoom.scale(1 - autopilotSpeed).plus(zoomTo.scale(autopilotSpeed));
            }
            pan = newPan;
            //zoom = zoom.scale(0.9).plus(zoom_to.scale(0.1));
            //pan = pan.scale(0.9).plus(pan_to.scale(0.1));
            if (coordsLive) {
                panInput.value = pan.ctostring();
                zoomInput.value = zoom.mag() + "";
            }
            //const inpColor = scol(Math.log(zoom.mag()),undefined,64,128);
            //coords.style.color = inpColor;
            updateViewbox();
            if (mousePath == "") {
                mousePathPos = toZ(mousePos);
                mousePath = "M " + toSVG(mousePathPos).str() + " L ";
            }
            for (let i = 0; i < settings.orbitStepRate; i++) {
                //let g = mandGrad(settings.iterations,mousePathPos);
                //mousePathPos = mousePathPos.plus(g.unscale((g.mag()+1e-10)*1000));

                mousePathPos = mand_step(mousePathPos, toZ(mousePos));

                //let p = findPeriod(mousePathPos);
                //mousePathPos = mand_iter_n(p,mousePathPos,mousePathPos);
                if (toSVG(mousePathPos).isFinite() && toSVG(mousePathPos).mag2() < 1e60)
                    mousePath += toSVG(mousePathPos).str() + " ";


            }
            if (nodeMode && prevNode !== undefined) {
                svg_mousePath.setAttribute("d", "M " + toSVG(prevNode.pos).str() + " L " + toSVG(toZ(mousePos)).str());
            } else {
                svg_mousePath.setAttribute("d", mousePath);
            }
            let width = zoom.mag() * 0.0005 * SVGzoom;
            svg_mousePath.setAttribute("stroke-width", width + "");
            if (current_time === undefined) {
                current_time = time;
            }
            let dt = time - current_time;
            current_time = time;
            if (dt > 0) {
                const alpha = Math.exp(-1 * dt / 1000);
                avgfps = avgfps * alpha + (1 - alpha) * 1000 / dt;
            }
            document.getElementById("debug_layer").children[1].textContent = "fps:" + avgfps;
            document.getElementById("fps").textContent = "avg fps:" + Math.round(avgfps * 100) / 100;

            dt *= (1 - nodeMode_v) ** 5;
            for (let n of nodes) {
                n.step(dt);
                let d = toZ(mousePos).minus(n.pos);
                //n.force = n.force.plus(d.unscale(-((d.mag2()**2)*500+1e-5)));
            }
            for (let e of edges) {
                e.step(dt); //line 2703
            }
            regenDebt = Math.min(16, regenDebt + lerp(4, regenAmount, Math.min(1, (nodeMode_v ** 5) * 1.01)));
            for (; regenDebt > 0; regenDebt--) {
                render_hair(Math.random() * settings.renderSteps);
            }
            regenAmount = 0;
            nodeMode_v = lerp(nodeMode_v, nodeMode, 0.125);
            window.requestAnimationFrame(nodeStep); //line 2711
        }
        nodeStep();


        //connectRandom(10);




        addEventListener("resize", (event) => { });


        document.addEventListener('wheel', (event) => {
            // Get the element that the user is scrolling on
            let targetElement = event.target;

            // Check if the target is a textarea and if so, ignore the zoom logic
            if (targetElement.tagName.toLowerCase() === 'textarea') {
                return;
            }
            if (event.getModifierState(settings.rotateModifier)) {
                autopilotSpeed = 0;
                coordsLive = true;
                let amount = event.wheelDelta * settings.rotateModifierSpeed;
                let p = toZ(new vec2(event.pageX, event.pageY));
                let zc = p.minus(pan);
                // p = zoom*center+pan = zoom'*center+pan'
                // zoom' = zoom*rot
                // pan' = pan + (zoom*center-zoom*rot*center)
                //      = pan + (1-rot) * zoom*center
                let r = new vec2(Math.cos(amount), Math.sin(amount));
                zoom = zoom.cmult(r);
                pan = pan.plus(zc.cmult(new vec2(1, 0).minus(r)));
                cancel(event);
                return;
            }
            if (settings.scroll === "zoom") {
                autopilotSpeed = 0;
                coordsLive = true;
                let dest = toZ(mousePos);
                regenAmount += Math.abs(event.wheelDelta);
                let amount = Math.exp(event.wheelDelta * settings.zoomSpeed);
                zoom = zoom.scale(amount);
                pan = dest.scale(1 - amount).plus(pan.scale(amount));
                cancel(event);
            } else if (settings.scroll === "pan") {
                autopilotSpeed = 0;
                coordsLive = true;
                let dest = toZ(mousePos);
                let dp;
                let amount;
                if (event.ctrlKey) {
                    dp = new vec2(0, 0);
                    amount = event.deltaY * settings.zoomSpeed;
                } else {
                    dp = toDZ(new vec2(event.deltaX, event.deltaY).scale(settings.panSpeed));
                    amount = event.deltaZ * settings.zoomSpeed;
                }
                regenAmount += Math.hypot(event.deltaX, event.deltaY, event.deltaZ);
                amount = Math.exp(amount)
                zoom = zoom.scale(amount);
                pan = dest.scale(1 - amount).plus(pan.scale(amount)).plus(dp);
                cancel(event);
                event.preventDefault();
            }
        });
        let mouseDown = false;
        let mouseDownPos = new vec2(0, 0);
        addEventListener("mousedown", (event) => {
            autopilotSpeed = 0;
            mouseDownPos = mousePos.scale(1);
            mouseDown = true;
            cancel(event);
        });
        addEventListener("mouseup", (event) => {
            mouseDown = false;
            if (movingNode !== undefined) {
                movingNode.onmouseup(event);
            }
        });
        addEventListener("mousemove", (event) => {
            if (mouseDown) {
                autopilotSpeed = 0;
                coordsLive = true;
                let delta = mousePos.minus(mouseDownPos);
                pan = pan.minus(toDZ(delta));
                regenAmount += delta.mag() * 0.25;
                mouseDownPos = mousePos.scale(1);
            }
        });
        addEventListener("keydown", (event) => {
            //console.log(event);
            if (event.key === settings.nodeModeKey) {
                if (settings.nodeModeTrigger === "down") {
                    if (settings.nodeModeKey === "CapsLock") {
                        nodeMode = event.getModifierState("CapsLock");
                    } else {
                        nodeMode = 1;
                    }
                } else if (settings.nodeModeTrigger === "toggle") {
                    nodeMode = 1 - nodeMode;
                }
            } else if (event.key === "Escape") {
                for (let n of nodes) {
                    n.followingMouse = 0;
                }
            }
        });

        function adjustTextareaHeight(textarea) {
            textarea.style.height = "";
            textarea.style.height = textarea.scrollHeight + "px";
        }

        let pyodideLoadingPromise = null;
        let pyodide = null;

        async function loadPyodideAndSetup() {
            // Load Pyodide
            let pyodideLoadPromise = loadPyodide({
                indexURL: "https://cdn.jsdelivr.net/pyodide/v0.23.0/full/",
            });
            pyodide = await pyodideLoadPromise;

            // Load commonly used packages
            return Promise.all([
                pyodide.loadPackage('numpy'),
                pyodide.loadPackage('pandas'),
                pyodide.loadPackage('matplotlib'),
                pyodide.loadPackage('scipy'),
                pyodide.loadPackage('py'),
                pyodide.loadPackage('sympy'),
                pyodide.loadPackage('networkx'),
            ]);

            console.log('Pyodide and packages loaded');
        }

        async function runPythonCode(code, pythonView) {
            // Display a loading message
            pythonView.innerHTML = "Initializing Pyodide and dependencies...";

            // If Pyodide is not loaded yet, start loading it
            if (!pyodide) {
                if (!pyodideLoadingPromise) {
                    pyodideLoadingPromise = loadPyodideAndSetup();
                }
                await pyodideLoadingPromise;
            }

            try {
                // Clear the pythonView
                pythonView.innerHTML = "";

                // Run the code and get the result
                let result = pyodide.runPython(code);

                // Create a new div for the result
                let resultDiv = document.createElement("div");

                // Append the output to the new div
                resultDiv.innerHTML = result || '';

                // Append the new div to the pythonView
                pythonView.appendChild(resultDiv);

                // Return the resultDiv's innerHTML
                return resultDiv.innerHTML;
            } catch (error) {
                // If an error occurred, return the error message
                return error.message;
            }
        }

        function observeParentResize(parentDiv, iframe, paddingWidth = 50, paddingHeight = 80) {
            const resizeObserver = new ResizeObserver((entries) => {
                for (let entry of entries) {
                    const {
                        width,
                        height
                    } = entry.contentRect;
                    iframe.style.width = Math.max(0, width - paddingWidth) + "px";
                    iframe.style.height = Math.max(0, height - paddingHeight) + "px";
                }
            });

            resizeObserver.observe(parentDiv);
            return resizeObserver;
        }

        function createTextNode(name = '', text = '', sx = undefined, sy = undefined, x = undefined, y = undefined) {
            let t = document.createElement("input");
            t.setAttribute("type", "text");
            t.setAttribute("value", "untitled");
            t.setAttribute("style", "background:none; ");
            t.classList.add("title-input");

            let n = document.createElement("textarea");
            n.classList.add('custom-scrollbar');
            n.onmousedown = cancel;
            n.setAttribute("type", "text");
            n.setAttribute("size", "11");
            n.setAttribute("style", "background-color: #222226; color: #bbb; overflow-y: scroll; resize: both; width: 218px;");

            let elements = [n];
            if (document.getElementById('code-checkbox') && document.getElementById('code-checkbox').checked) {
                let checkbox = document.createElement("input");
                checkbox.type = "checkbox";
                checkbox.onchange = async function () {
                    if (this.checked) {
                        n.style.display = "none";
                        let re = /```(.*?)\n([\s\S]*?)```/gs;
                        let codeBlocks = n.value.matchAll(re);

                        for (let block of codeBlocks) {
                            let language = block[1].trim();
                            let code = block[2];

                            if (language === 'python') {
                                if (!n.pythonView) {
                                    n.pythonView = document.createElement("div");
                                    n.parentNode.insertBefore(n.pythonView, n.nextSibling);
                                }
                                n.pythonView.style.display = "block";
                                console.log('Running Python code...');
                                let result = await runPythonCode(code, n.pythonView);
                                console.log('Python code executed, result:', result);
                            } else if (language === 'html' || language === '') {
                                // Remove the old iframe if it exists
                                if (n.htmlView) {
                                    n.htmlView.remove();
                                }
                                // Always create a new iframe
                                n.htmlView = document.createElement("iframe");
                                n.htmlView.style.border = "none";
                                n.htmlView.style.boxSizing = "border-box";

                                // Prevent event bubbling
                                n.htmlView.onmousedown = function (event) {
                                    event.stopPropagation();
                                };

                                // Insert the iframe into the DOM
                                n.parentNode.insertBefore(n.htmlView, n.nextSibling);

                                n.htmlView.srcdoc = code;

                                let windowDiv = n.htmlView.parentNode;
                                while (windowDiv && (!windowDiv.win || !windowDiv.classList.contains('window'))) {
                                    windowDiv = windowDiv.parentNode;
                                }
                                if (windowDiv) {
                                    observeParentResize(windowDiv, n.htmlView);
                                }
                            }
                        }
                    } else {
                        n.style.display = "block";
                        if (n.htmlView) {
                            n.htmlView.style.display = "none";
                            n.htmlView.srcdoc = "";
                        }
                    }
                };
                elements.push(checkbox);
            }
            let node = addNodeAtNaturalScale(name, elements);

            let max_height = 300; // Set maximum height in pixels

            // Add a flag to the node to track resizing
            node.isResizing = false;

            // Add a mousedown event listener to track user interactions with the resize handle
            n.addEventListener('mousedown', (e) => {
                node.isResizing = true;
            });

            // Add a mouseup event listener to re-enable auto-height adjustment
            n.addEventListener('mouseup', (e) => {
                node.isResizing = false;
            });

            // Function to adjust the height and handle overflow of the textarea
            const adjustHeight = (element) => {
                if (!node.isResizing) {
                    if (element.scrollHeight > max_height) {
                        if (element.clientHeight < max_height) {
                            element.style.height = max_height + 'px';
                            element.style.overflowY = 'auto';
                        }
                    } else {
                        element.style.height = 'auto'; // Reset the height
                        element.style.height = element.scrollHeight + 'px'; // Set to scrollHeight
                    }
                }
            };

            // Function to auto-scroll to the bottom if user is already at the bottom
            const autoScrollToBottom = (element) => {
                if (element.scrollTop + element.clientHeight >= element.scrollHeight - 5) {
                    // Using scrollIntoView to smoothly scroll to the bottom
                    element.scrollIntoView(false);
                }
            };

            // Modify the oninput function to check the isResizing flag and max height
            n.oninput = function () {
                adjustHeight(this);
            };

            // Add the observer to the node
            node.observer = new ResizeObserver(() => {
                adjustHeight(n);
            });

            // Start observing the textarea element
            node.observer.observe(n);

            // Track the previous scrollHeight
            let prevScrollHeight = n.scrollHeight;

            // Use a MutationObserver to watch for changes to the textarea's value
            const mutationObserver = new MutationObserver(() => {
                if (n.scrollHeight !== prevScrollHeight) {
                    adjustHeight(n);
                    autoScrollToBottom(n);
                    prevScrollHeight = n.scrollHeight;
                }
            });

            mutationObserver.observe(n, {
                childList: true,
                subtree: true,
                characterData: true
            });

            if (sx !== undefined) {
                x = (new vec2(sx, sy)).cmult(zoom).plus(pan);
                y = x.y;
                x = x.x;
            }

            if (x !== undefined) {
                node.pos.x = x;
            }

            if (y !== undefined) {
                node.pos.y = y;
            }

            node.push_extra_cb((node) => {
                return {
                    f: "textarea",
                    a: {
                        p: [0, 0, 1],
                        v: t.value
                    }
                };
            })

            node.push_extra_cb((node) => {
                return {
                    f: "textarea",
                    a: {
                        p: [0, 1, 0],
                        v: n.value
                    }
                };
            })

            return node;
        }


        addEventListener("dblclick", (event) => {
            if (nodeMode) {
                if (prevNode) {
                    prevNode = undefined;
                } else {
                    //addNodeAtNaturalScale()
                    //let n = document.createElementNS("http://www.w3.org/2000/svg","svg");
                    //n.addChild(
                    //<svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="blue"/></svg>
                    createTextNode();
                }
            }
            cancel(event);
        });

        let touches = new Map();

        addEventListener("touchstart", (ev) => {
            //pan = pan.plus(new vec2(0,1))
            for (let i = 0; i < ev.changedTouches.length; i++) {
                const touch = ev.changedTouches.item(i);
                touches.set(touch.identifier, {
                    prev: touch,
                    now: touch
                });
            }
        }, false);
        addEventListener("touchcancel", (ev) => {
            for (let i = 0; i < ev.changedTouches.length; i++) {
                const touch = ev.changedTouches.item(i);
                touches.delete(touch.identifier);
            }
        }, false);
        addEventListener("touchend", (ev) => {
            //pan = pan.plus(new vec2(0,-1))
            switch (touches.size) {
                case 2: //tap to zoom
                    if (ev.changedTouches.length == 1) {
                        const id = ev.changedTouches.item(0).identifier;
                        const t = touches.get(id);
                        if (t && t.prev == t.now) { //hasn't moved
                            const ts = [...touches.keys()];
                            const other = touches.get(ts[0] === id ? ts[1] : ts[0])
                            const {
                                s,
                                o
                            } = windowScaleAndOffset();
                            const amount = Math.exp(-(other.now.clientY - t.now.clientY) / s);
                            const dest = toZ(new vec2(other.now.clientX, other.now.clientY));
                            zoom = zoom.scale(amount);
                            pan = dest.scale(1 - amount).plus(pan.scale(amount));
                        }
                    }
                    break;

            }
            for (let i = 0; i < ev.changedTouches.length; i++) {
                const touch = ev.changedTouches.item(i);
                touches.delete(touch.identifier);
            }
        }, false);
        addEventListener("touchmove", (ev) => {
            for (let i = 0; i < ev.changedTouches.length; i++) {
                const touch = ev.changedTouches.item(i);
                touches.set(touch.identifier, {
                    prev: touches.get(touch.identifier)?.now,
                    now: touch
                });
            }
            switch (touches.size) {
                case 1:
                    autopilotSpeed = 0;
                    coordsLive = true;
                    const t = [...touches.values()][0];
                    pan = pan.plus(toDZ(new vec2(t.prev.clientX, t.prev.clientY).minus(new vec2(t.now.clientX, t.now.clientY))));
                    cancel(ev);
                    break;
                case 2:
                /*
                const pts = [...touches.values()];
                const p1p = toS(new vec2(pts[0].prev.clientX,pts[0].prev.clientY));
                const p2p = toS(new vec2(pts[1].prev.clientX,pts[1].prev.clientY));
                const p1n = toS(new vec2(pts[0].now.clientX,pts[0].now.clientY));
                const p2n = toS(new vec2(pts[1].now.clientX,pts[1].now.clientY));
                //want to find new zoom,pan such that
                // old toZ(p1p) = new toZ(p1n)
                // old toZ(p2p) = new toZ(p2n)
                //
                //  toZ(x) ≈ x*zoom + pan
                //
                // so, we want zoom' pan' s.t.
                //  p1p*zoom + pan = p1n*zoom' + pan'
                //  p2p*zoom + pan = p2n*zoom' + pan'
                //
                //  (p2p-p1p) * zoom = (p2n-p1n) * zoom'
                //  (p1p+p2p)*zoom + 2pan = (p1p+p2p)*zoom' + 2pan'
                //
                //  zoom' = zoom * (p2p-p1p)/(p2n-p1n)
                //  pan' = pan + (p1p+p2p)*zoom/2 - (p1p+p2p)*zoom'/2
                //       = pan + (p1p+p2p)*(zoom - zoom')/2
                const nzoom = zoom.cmult( p2p.minus(p1p).cdiv( p2n.minus(p1n)));
                pan = pan.plus(p2p.plus(p1p).cmult(zoom.minus(nzoom)).scale(0.5));
                zoom = nzoom;


                ev.preventDefault();
                cancel(ev);
                break;
                */
                default:
                    break;
            }


        }, false);




        var gestureStartParams = {
            rotation: 0,
            x: 0,
            y: 0,
            scale: 0,
            zoom: new vec2(),
            pan: new vec2()
        };
        addEventListener("gesturestart", (e) => {
            e.preventDefault();
            //console.log(e);
            gestureStartParams.rotation = e.rotation;
            gestureStartParams.scale = e.scale;
            gestureStartParams.x = e.pageX;
            gestureStartParams.y = e.pageY;
            gestureStartParams.zoom = zoom;
            gestureStartParams.pan = pan;

        });
        addEventListener("gesturechange", (e) => {
            e.preventDefault();
            //console.log(e);
            let d_theta = e.rotation - gestureStartParams.rotation;
            let d_scale = e.scale;
            let r = -e.rotation * settings.gestureRotateSpeed;
            pan = gestureStartParams.pan;
            zoom = gestureStartParams.zoom;
            let r_center = toZ(new vec2(e.pageX, e.pageY));
            let s = 0;
            zoom = gestureStartParams.zoom.cmult(new vec2(Math.cos(r), Math.sin(r)));
            if (e.scale !== 0) {
                let s = 1 / e.scale;
                zoom = zoom.scale(s);
                regenAmount += Math.abs(Math.log(s)) * settings.maxLines;
            }
            let dest = r_center;
            let amount = s;
            let dp = r_center.minus(gestureStartParams.pan);
            pan = gestureStartParams.pan.plus(
                dp.minus(dp.cmult(zoom.cdiv(gestureStartParams.zoom))));
            //pan = dest.scale(1-amount).plus(gestureStartParams.pan.scale(amount));

        });
        addEventListener("gestureend", (e) => {
            e.preventDefault();
        });


        addEventListener("keyup", (event) => {
            //console.log(event);
            if (event.key === settings.nodeModeKey) {
                if (settings.nodeModeTrigger === "down") {
                    nodeMode = 0;
                    cancel(event);
                }
            }
        });




        //todo sshift click for node mode (Attach nodes to eachother)
        //todo patches for zoom in

        function random_screen_pt_z() {
            let svgbb = svg.getBoundingClientRect();
            return toZ(new vec2(Math.random() * svgbb.width, Math.random() * svgbb.height));
        }

        function render_hair(n) { //todo make faster.
            let iters = settings.iterations;
            let maxLines = settings.maxLines;
            let tries = 1;
            let pt;
            do {
                pt = random_screen_pt_z();
                for (let i = (1 - Math.random() ** 2) * (tries * 4); i > 1; i--) {
                    let gz = mandGrad(iters, pt)
                    pt = pt.plus(gz.unscale(gz.mag2() * 10 + 1));
                    //if (mand_i(pt,iters) > iters){
                    //    pt = (new vec2(Math.random()*2-1,Math.random()*2-1)).cmult(zoom).cadd(pan);
                    //}
                }
                tries--;
            } while (tries > 0 && mand_i(pt, iters) > iters)
            /*if (mand_i(pt,iters) > iters || pt.mag2()>8){
                return;
            }*/

            //let level = mandelbrott_dist(256,pt);
            //let width = 1/(level+5)**2;
            //let width = 1/(mandGrad(256,pt).mag()**1.5+1);


            let r = "M " + toSVG(pt).str() + " " + settings.renderDChar + " ";
            let length = 0;
            let n0 = n;
            let opt = pt;
            let na = 0;
            let opacity = 1;
            if (mand_i(pt, iters) > iters) {
                //interior coloring
                /*let p = findPeriod(pt,pt,1e-12,iters);
                for (; n > 0; n--){
                    let npt = mand_iter_n(p,pt,pt);
                    let delta = npt.minus(pt);
                    delta = delta.cpow(new vec2(0.5,0));
                    npt = pt.plus(delta.scale(0.1));
                    if (mand_i(npt,iters)<=iters){
                        break;
                    }
                    r += toSVG(npt).str()+" ";
                    length += npt.minus(pt).mag();
                    pt = npt;
                }*/
                let p = findInfimum(iters, pt);
                for (; n > 0; n--) {
                    let delta = gradzr(((z) => (mand_iter_n(p.i, z, z).mag2())), pt, 1e-5);
                    delta = delta.unscale(delta.mag() + 1e-300).scale(zoom.mag() * .1);
                    //debugger
                    npt = pt.plus(delta.scale(-settings.renderStepSize));
                    if (mand_i(npt, iters) <= iters) {
                        break;
                    }
                    if (!toSVG(npt).isFinite()) break;
                    r += toSVG(npt).str() + " ";
                    na += 1;
                    length += npt.minus(pt).mag();
                    pt = npt;
                }
                opacity = 0.1;

                length /= 4;
            } else {
                if (mandelbrott_dist(iters, pt) < settings.maxDist) return;
                for (let p of trace_circle(iters, pt, Math.random() > 0.5 ? settings.renderStepSize : -settings.renderStepSize)) {
                    //console.log(p);
                    //if ((n&3) == 0)
                    if (!toSVG(p).isFinite()) break;
                    r += toSVG(p).str() + " ";
                    na += 1;
                    n -= 1;
                    if (n < 0) {
                        break;
                    }
                    length += p.minus(pt).mag();
                    pt = p;
                }
                color = scol(mandelbrott_dist(iters, pt));
            }
            if (na === 0) return;
            let width = Math.min(settings.renderWidthMult * length / n0, 0.1);
            let pathn = document.createElementNS("http://www.w3.org/2000/svg", "path");
            pathn.setAttribute("fill", "none");
            pathn.setAttribute("stroke", mcol(iters, opt));
            pathn.setAttribute("stroke-width", "" + width * SVGzoom);
            pathn.setAttribute("stroke-opacity", "" + opacity);
            pathn.setAttribute("d", r);
            svg_bg.appendChild(pathn);
            if (svg_bg.children.length > maxLines) {
                svg_bg.removeChild(svg_bg.children[0]);
            }
        }





        function dropHandler(ev) {
            console.log(ev);

            ev.preventDefault();
            let files = [];
            if (ev.dataTransfer.items) {
                // Use DataTransferItemList interface to access the file(s)
                [...ev.dataTransfer.items].forEach((item, i) => {
                    // If dropped items aren't files, reject them
                    if (item.kind === 'file') {
                        const file = item.getAsFile();
                        files.push(file);
                        console.log(`… file[${i}].name = ${file.name}`);
                    }
                });
            } else {
                // Use DataTransfer interface to access the file(s)
                [...ev.dataTransfer.files].forEach((file, i) => {
                    files.push(file)
                    console.log(`… file[${i}].name = ${file.name}`);
                });
            }
            console.log(files);
            //https://stackoverflow.com/questions/3814231/loading-an-image-to-a-img-from-input-file
            if (FileReader && files && files.length) {
                for (let i = 0; i < files.length; i++) {

                    let baseType = files[i].type.split("/")[0];
                    let url = URL.createObjectURL(files[i]);
                    let img;
                    let content = [];

                    let add = function (scale) {
                        let node = windowify(files[i].name, content, toZ(mousePos), (zoom.mag2() ** settings.zoomContentExp), scale);
                        /*node.push_extra_cb((node) => { //superceeded by new rewindowify (todo)
                          return {
                            f: "textarea",
                            a: {
                              p: [0, 1],
                              v: files[i].name.value
                            }
                          };
                        })*/
                        htmlnodes_parent.appendChild(node.content);
                        registernode(node);
                        node.followingMouse = 1;
                        node.draw();
                        node.mouseAnchor = toDZ(new vec2(0, -node.content.offsetHeight / 2 + 6));
                    }
                    console.log("loading " + baseType);
                    switch (baseType) {
                        case "image":
                            img = document.createElement('img');
                            img.ondragstart = (e) => false;
                            content = [
                                img
                            ];
                            img.style = "display: block";
                            img.onload = function () {
                                let s = 512 / Math.hypot(img.naturalWidth, img.naturalHeight);
                                //img.style.transform = "scale("+s+","+s+")";
                                img.width = img.naturalWidth * s;
                                img.height = img.naturalHeight * s;
                                add(1);
                                URL.revokeObjectURL(img.src);
                            }
                            break;
                        case "audio":
                            img = new Audio();
                            img.setAttribute("controls", "");
                            //let c = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                            //c.setAttribute("viewBox","0 0 128 64");
                            //let name = document.createElementNS("http://www.w3.org/2000/svg","text");
                            //name.setAttribute("x","0");name.setAttribute("y","0");
                            //name.appendChild(document.createTextNode(files[i].name));
                            //c.appendChild(name);
                            img.style = "display: block";
                            content = [
                                img
                            ];
                            add(1);
                            //div.appendChild(c);
                            break;
                        case "video":
                            img = document.createElement('video');
                            img.style = "display: block";
                            img.setAttribute("controls", "");
                            content = [
                                img
                            ];
                            add(1);
                            break;
                        default:
                            break;
                    }
                    img.src = url;


                }
            }

            // Not supported
            else {
                // fallback -- perhaps submit the input to an iframe and temporarily store
                // them on the server until the user's session ends.
                console.log("FileReader not supported or no files");
            }
        }


        function registernode(node) {
            let id = nodes.length;
            let div = node.content;
            /*div.setAttribute("onclick","(e)=>nodes["+id+"].onclick(e)");
            div.setAttribute("onmousedown","(e)=>nodes["+id+"].onmousedown(e)");
            div.setAttribute("onmouseup","(e)=>nodes["+id+"].onmouseup(e)");
            div.setAttribute("onmousemove","(e)=>nodes["+id+"].onmousemove(e)");*/
            nodes.push(node);
            nodeMap[node.uuid] = node;
        }

        function dragOverHandler(ev) {
            ev.preventDefault();
        }

        function nodemousedown(id) {
            if (id < nodes.length) {
                nodes[id].mousedown();
            }
        }

        function nodemouseup(id) {
            if (id < nodes.length) {
                nodes[id].mouseup();
            }
        }

        function nodemousemove(id) {
            if (id < nodes.length) {
                nodes[id].mousemove();
            }
        }

        function nodeclick(id) {
            if (id < nodes.length) {
                nodes[id].mouseclick();
            }
        }


        function cancel(event) {
            if (event.stopPropagation) {
                event.stopPropagation(); // W3C model
            } else {
                event.cancelBubble = true; // IE model
            }
        }

        function addNodeAtNaturalScale(title, content, scale = 1, nscale_mult = 1, window_it = true) {
            let node;
            if (window_it) {
                let pos = toZ(mousePos)
                if (!Array.isArray(content)) {
                    content = [content];
                }
                node = windowify(title, content, pos, nscale_mult * (zoom.mag2() ** settings.zoomContentExp), scale);
                htmlnodes_parent.appendChild(node.content);
            } else {
                let div = document.createElement('div');
                node = new Node(toZ(mousePos), div, nscale_mult * (zoom.mag2() ** settings.zoomContentExp), scale);
                div.appendChild(content);
                htmlnodes_parent.appendChild(div);
            }
            registernode(node)
            return node;
        }


        addEventListener("paste", (event) => {
            console.log(event);
            let cd = (event.clipboardData || window.clipboardData);
            let content = document.createElement("div");
            content.innerHTML = cd.getData("text");
            let t = document.createElement("input");
            t.setAttribute("type", "text");
            t.setAttribute("value", "untitled");
            t.setAttribute("style", " background:none;");
            t.classList.add("title-input");
            let node = windowify("untitled", [content], toZ(mousePos), (zoom.mag2() ** settings.zoomContentExp), 1);
            htmlnodes_parent.appendChild(node.content);
            registernode(node);
            node.followingMouse = 1;
            node.draw();
            node.mouseAnchor = toDZ(new vec2(0, -node.content.offsetHeight / 2 + 6));
        });

        addEventListener("paste", (event) => {
            if (event.target.tagName.toLowerCase() === "textarea") {
                event.stopPropagation();
                console.log("Paste disabled for textarea");
            }
        }, true);

        function gcd(a, b) {
            if (b === 0) {
                return a;
            }
            return gcd(b, a % b);
        }

        function findPeriod(c, z = new vec2(0, 0), epsilon2 = 1e-7, maxiters = 256) {
            let zf = mand_step(z, c);
            let i = 1;
            let p = 0;
            for (; i < maxiters; i++) {
                if (zf.minus(z).mag2() <= epsilon2) {
                    p = i;
                    break
                }
                zf = mand_step(zf, c);
                zf = mand_step(zf, c);
                z = mand_step(z, c);
            }
            for (; i < maxiters; i++) {
                if (zf.minus(z).mag2() <= epsilon2) {
                    p = gcd(p, i);
                }
                zf = mand_step(zf, c);
                zf = mand_step(zf, c);
                z = mand_step(z, c);
            }
            return p;
        }

        function mand_iter_n(n, c, z = new vec2(0, 0)) {
            for (let i = 0; i < n; i++) {
                z = mand_step(z, c);
            }
            return z;
        }

        function findInfimum(iters, z, c = undefined) {
            if (c === undefined) {
                c = z;
            }
            let besti = 0;
            let bestz = z;
            let bestd = z.mag2();
            for (let i = 1; i <= iters; i++) {
                z = mand_step(z, c);
                let d = z.mag2();
                if (d < bestd) {
                    bestd = d;
                    besti = i;
                    bestz = z;
                }
            }
            return {
                i: besti,
                z: bestz
            };
        }




        //START OF AI




        function getTokenCount(messages) {
            let tokenCount = 0;
            messages.forEach(message => {
                // match words, numbers, punctuations and whitespace
                let tokens = message.content.match(/[\w]+|[^\s\w]/g);
                if (tokens !== null) {
                    tokenCount += tokens.length;
                }
            });
            return tokenCount;
        }

        let aiResponding = false;
        let latestUserMessage = null;
        let controller = new AbortController();
        let shouldContinue = true;

        function removeLastResponse() {
            const noteInput = document.getElementById("note-input");
            const lines = noteInput.value.split("\n");

            // Find the index of the last "Prompt:"
            let lastPromptIndex = lines.length - 1;
            while (lastPromptIndex >= 0 && !lines[lastPromptIndex].startsWith("Prompt:")) {
                lastPromptIndex--;
            }

            // Remove all lines from the last "Prompt:" to the end
            if (lastPromptIndex >= 0) {
                lines.splice(lastPromptIndex, lines.length - lastPromptIndex);
                noteInput.value = lines.join("\n");
            }
        }

        function haltResponse() {
            if (aiResponding) {
                // AI is responding, so we want to stop it
                controller.abort();
                aiResponding = false;
                shouldContinue = false;
                document.getElementById("regen-button").textContent = '↻';
                document.getElementById("prompt").value = latestUserMessage; // Add the last user message to the prompt input
            }
        }

        function regenerateResponse() {
            if (!aiResponding) {
                // AI is not responding, so we want to regenerate
                removeLastResponse(); // Remove the last AI response
                document.getElementById("prompt").value = latestUserMessage; // Restore the last user message into the input prompt
                document.getElementById("regen-button").textContent = '↻';

            }
        }

        document.getElementById("regen-button").addEventListener("click", function () {
            if (aiResponding) {
                haltResponse();
            } else {
                regenerateResponse();
            }
        });

        function checkOtherModel(selectElement) {
            var modelInput = document.getElementById('model-input');
            if (selectElement.value === 'other') {
                // If 'Other...' is selected, show the text input field
                modelInput.style.display = 'inline';
            } else {
                // Otherwise, hide the text input field and clear its value
                modelInput.style.display = 'none';
                modelInput.value = '';
            }
        }

        document.getElementById('max-tokens-slider').addEventListener('input', function (e) {
            document.getElementById('max-tokens-display').innerText = e.target.value;
        });

        async function callChatGPTApi(messages, stream = false) {
            // Reset shouldContinue
            shouldContinue = true;

            // Update aiResponding and the button
            aiResponding = true;
            document.getElementById("regen-button").textContent = '❚❚'; // Halt unicode

            console.log("Messages sent to API:", messages);
            console.log("Token count for messages:", getTokenCount(messages));

            const API_KEY = document.getElementById("api-key-input").value;
            if (!API_KEY) {
                alert("Please enter your API key");
                return;
            }

            const API_URL = "https://api.openai.com/v1/chat/completions";

            const headers = new Headers();
            headers.append("Content-Type", "application/json");
            headers.append("Authorization", `Bearer ${API_KEY}`);

            // Create a new AbortController each time the function is called
            controller = new AbortController();
            let signal = controller.signal;

            // Add the signal to your fetch request options
            const temperature = document.getElementById('model-temperature').value;
            const modelSelect = document.getElementById('model-select');
            const modelInput = document.getElementById('model-input');
            const model = modelSelect.value === 'other' ? modelInput.value : modelSelect.value;
            let max_tokens = document.getElementById('max-tokens-slider').value;

            const requestOptions = {
                method: "POST",
                headers: headers,
                body: JSON.stringify({
                    model: model,
                    messages: messages,
                    max_tokens: parseInt(max_tokens),
                    temperature: parseFloat(temperature),
                    stream: stream,
                }),
                signal: signal,
            };

            try {
                const response = await fetch(API_URL, requestOptions);
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Error calling ChatGPT API:", errorData);
                    return "An error occurred while processing your request.";
                }

                const noteInput = document.getElementById("note-input");

                if (stream) {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder("utf-8");
                    let buffer = "";

                    while (true) {
                        const {
                            value,
                            done
                        } = await reader.read();
                        // Break the loop if streaming is done or the shouldContinue flag is set to false
                        if (done || !shouldContinue) break;

                        buffer += decoder.decode(value, {
                            stream: true
                        });

                        // If shouldContinue is false, stop processing
                        if (!shouldContinue) break;

                        // Handle content processing only when shouldContinue is true
                        if (shouldContinue) {
                            let contentMatch;
                            while ((contentMatch = buffer.match(/"content":"((?:[^\\"]|\\.)*)"/)) !== null) {
                                const content = JSON.parse('"' + contentMatch[1] + '"');

                                if (!shouldContinue) break;

                                if (content.trim() !== "[DONE]") {
                                    const isScrolledToBottom = noteInput.scrollHeight - noteInput.clientHeight <= noteInput.scrollTop + 1;
                                    if (shouldContinue) {
                                        noteInput.value += content;
                                    }
                                    if (isScrolledToBottom) {
                                        noteInput.scrollTop = noteInput.scrollHeight;
                                    }
                                    noteInput.dispatchEvent(new Event("input"));
                                }
                                buffer = buffer.slice(contentMatch.index + contentMatch[0].length);
                            }
                        }
                    }
                } else {
                    const data = await response.json();
                    console.log("Token usage:", data.usage);
                    return data.choices[0].message.content.trim();
                }
            } catch (error) {
                console.error("Error calling ChatGPT API:", error);
                return "An error occurred while processing your request.";
            } finally {
                aiResponding = false;
                document.getElementById("regen-button").textContent = '↻'; // Your desired refresh symbol here
            }
        }

        function getLastPromptsAndResponses(count, maxTokens) {
            const lines = document.getElementById("note-input").value.split("\n");
            const promptsAndResponses = [];
            let promptCount = 0;
            let tokenCount = 0;

            for (let i = lines.length - 1; i >= 0; i--) {
                if (lines[i].startsWith("Prompt:")) {
                    promptCount++;
                }
                if (promptCount > count) {
                    break;
                }
                tokenCount += lines[i].split(/\s+/).length;
                promptsAndResponses.unshift(lines[i]);
            }

            while (tokenCount > maxTokens) {
                const removedLine = promptsAndResponses.shift();
                tokenCount -= removedLine.split(/\s+/).length;
            }

            const lastPromptsAndResponses = promptsAndResponses.join("\n") + "\n";
            // console.log("Last prompts and responses:", lastPromptsAndResponses);
            return lastPromptsAndResponses;
        }

        async function fetchEmbeddings(text, model = "text-embedding-ada-002") {
            const API_KEY = document.getElementById("api-key-input").value;
            if (!API_KEY) {
                alert("Please enter your API key");
                return;
            }

            const API_URL = "https://api.openai.com/v1/embeddings";

            const headers = new Headers();
            headers.append("Content-Type", "application/json");
            headers.append("Authorization", `Bearer ${API_KEY}`);

            const body = JSON.stringify({
                model: model,
                input: text,
            });

            const requestOptions = {
                method: "POST",
                headers: headers,
                body: body,
            };

            try {
                const response = await fetch(API_URL, requestOptions);
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Error fetching embeddings:", errorData);
                    return [];
                }

                const data = await response.json();
                return data.data[0].embedding;
            } catch (error) {
                console.error("Error fetching embeddings:", error);
                return [];
            }
        }

        class LRUCache {
            constructor(maxSize) {
                this.maxSize = maxSize;
                this.cache = new Map();
            }

            get(key) {
                const value = this.cache.get(key);
                if (value !== undefined) {
                    this.cache.delete(key);
                    this.cache.set(key, value);
                }
                return value;
            }

            set(key, value) {
                if (this.cache.size >= this.maxSize) {
                    const oldestKey = this.cache.keys().next().value;
                    this.cache.delete(oldestKey);
                }
                this.cache.set(key, value);
            }
        }

        const MAX_CACHE_SIZE = 100;
        const nodeCache = new LRUCache(MAX_CACHE_SIZE);

        function getNodeText() {
            const nodes = [];
            for (const child of htmlnodes_parent.children) {
                if (child.firstChild && child.firstChild.win) {
                    const node = child.firstChild.win;
                    const titleInput = node.content.querySelector("input.title-input");
                    const contentWrapper = node.content.querySelector("div.content");
                    const contentElement = contentWrapper ? contentWrapper.querySelector("textarea") : null;
                    const contentText = contentElement ? contentElement.value : '';

                    nodes.push({
                        ...node,
                        searchStrings: [
                            titleInput ? titleInput.value : '',
                            contentText ? contentText : ''
                        ]
                    });
                }
            }
            return nodes;
        }

        async function embeddedSearch(searchTerm) {
            let keywords = searchTerm.toLowerCase().split(/,\s*/);

            const nodes = getNodeText();

            if (nodes.length === 0) {
                return [];
            }

            let matched = [];

            const fetchNodeEmbedding = async (node) => {
                const cachedEmbedding = nodeCache.get(node.uuid);
                return cachedEmbedding ? cachedEmbedding : await fetchEmbeddings(node.content.innerText);
            };

            const searchTermEmbeddingPromise = fetchEmbeddings(searchTerm);
            const nodeEmbeddingsPromises = nodes.map(fetchNodeEmbedding);
            const [keywordEmbedding, ...nodeEmbeddings] = await Promise.all([searchTermEmbeddingPromise, ...nodeEmbeddingsPromises]);

            for (let i = 0; i < nodes.length; i++) {
                const n = nodes[i];

                const titleMatchScore = n.searchStrings[0].toLowerCase().includes(searchTerm.toLowerCase()) ? 1 : 0;
                const contentMatchScore = keywords.filter(keyword => {
                    const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                    return n.searchStrings[1].match(regex);
                }).length;
                const weightedTitleScore = titleMatchScore * 10;
                const weightedContentScore = contentMatchScore;

                const nodeEmbedding = nodeEmbeddings[i];

                const dotProduct = keywordEmbedding.reduce((sum, value, index) => sum + (value * nodeEmbedding[index]), 0);
                const keywordMagnitude = Math.sqrt(keywordEmbedding.reduce((sum, value) => sum + (value * value), 0));
                const nodeMagnitude = Math.sqrt(nodeEmbedding.reduce((sum, value) => sum + (value * value), 0));

                const cosineSimilarity = dotProduct / (keywordMagnitude * nodeMagnitude);

                const similarityThreshold = 0.5;
                const keywordMatchPercentage = 0.5;

                if (weightedTitleScore + weightedContentScore > 0 || cosineSimilarity > similarityThreshold) {
                    matched.push({
                        node: n,
                        title: n.title,
                        content: n.content.innerText,
                        weightedTitleScore: weightedTitleScore,
                        weightedContentScore: weightedContentScore,
                        similarity: cosineSimilarity,
                    });
                }
            }

            matched.sort((a, b) => (b.weightedTitleScore + b.weightedContentScore + b.similarity) - (a.weightedTitleScore + a.weightedContentScore + a.similarity));
            return matched.map(m => m.node);
        }



        const nodeTitlesAndContent = [];

        for (let key in nodes) {
            let nodeTitle = nodes[key].title;
            let nodeContent = nodes[key].plainText;
            nodeTitlesAndContent.push({
                title: nodeTitle,
                content: nodeContent
            });
        }

        function clearSearchHighlights(nodesArray) {
            for (const node of nodesArray) {
                node.content.classList.remove("search_matched");
                node.content.classList.remove("search_nomatch");
            }
        }



        async function generateKeywords(message, count) {
            // Get last prompts and responses
            const lastPromptsAndResponses = getLastPromptsAndResponses(1, 400);

            // Prepare the messages array
            const messages = [
                {
                    role: "system",
                    content: lastPromptsAndResponses,
                },
                {
                    role: "system",
                    content: `You provide key search terms for other LLMS`,
                },
                {
                    role: "user",
                    content: `Without any preface or final explanation, generate three salient, single word, comma seperated search terms for the following prompt: "${message}" Order the keywords by relevance in anticpation of user needs. Keywords should be generated through prediction of what keywords will recieve the most relevant search result for providing context to answer the prompt. Provide your generated words on a single line. Make sure your first search term is highly relevant if not a repeat of the most important word from the user message.`,
                },
            ];

            // Call the API
            const keywords = await callChatGPTApi(messages);

            // Return the keywords
            return keywords.split(',').map(k => k.trim());
        }


        function cosineSimilarity(vecA, vecB) {
            // Check for null or undefined vectors, or vectors of different lengths
            if (!vecA || !vecB || vecA.length !== vecB.length || vecA.length === 0 || vecB.length === 0) {
                return 0;
            }

            let dotProduct = 0;
            let vecASquaredSum = 0;
            let vecBSquaredSum = 0;

            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                vecASquaredSum += vecA[i] * vecA[i];
                vecBSquaredSum += vecB[i] * vecB[i];
            }

            const vecAMagnitude = Math.sqrt(vecASquaredSum);
            const vecBMagnitude = Math.sqrt(vecBSquaredSum);

            // Check if vectors are zero vectors after calculating magnitudes
            if (vecAMagnitude === 0 || vecBMagnitude === 0) {
                return 0;
            }

            return dotProduct / (vecAMagnitude * vecBMagnitude);
        }

        function sampleSummaries(summaries, top_n_links) {
            const sampledSummaries = [];
            for (let i = 0; i < top_n_links; i++) {
                if (summaries.length > 0) {
                    const randomIndex = Math.floor(Math.random() * summaries.length);
                    const randomSummary = summaries.splice(randomIndex, 1)[0];
                    sampledSummaries.push(randomSummary);
                }
            }
            return sampledSummaries;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function isNoveltyEnabled() {
            const checkbox = document.getElementById("novelty-checkbox");
            return checkbox.checked;
        }

        function isWikipediaEnabled() {
            const checkbox = document.getElementById("wiki-checkbox");
            return checkbox.checked;
        }

        async function getWikipediaSummaries(keywords, top_n_links = 3) {
            const allSummariesPromises = keywords.map(async (keyword) => {
                try {
                    const response = await fetch(
                        `http://localhost:5000/wikipedia_summaries?keyword=${keyword}&top_n_links=${top_n_links}`
                    );

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    const keywordSummaries = await calculateRelevanceScores(data, await fetchEmbeddings(keyword));
                    return keywordSummaries;
                } catch (error) {
                    console.error('Error fetching Wikipedia summaries:', error);
                    alert('Failed to fetch Wikipedia summaries. Please ensure your Wikipedia server is running on localhost:5000. Localhosts can be found at the Github link in the ? tab.');
                    return [];
                }
            });

            const allSummaries = await Promise.all(allSummariesPromises);
            const summaries = [].concat(...allSummaries); // Flatten the array of summaries

            // Sort the summaries by relevance score in descending order
            summaries.sort((a, b) => b.relevanceScore - a.relevanceScore);

            const combinedSummaries = [];

            // Include the top matched summary
            combinedSummaries.push(summaries[0]);

            // Check if the novelty checkbox is checked
            if (isNoveltyEnabled()) {
                // If checked, randomly pick two summaries from the remaining summaries
                const remainingSummaries = summaries.slice(1);
                shuffleArray(remainingSummaries);
                combinedSummaries.push(...sampleSummaries(remainingSummaries, 2));
            } else {
                // If not checked, push the top n summaries
                combinedSummaries.push(...summaries.slice(1, top_n_links));
            }

            return combinedSummaries;
        }


        async function calculateRelevanceScores(summaries, searchTermEmbedding) {
            // Use the existing searchTermEmbedding for cosine similarity calculations
            const titleEmbeddings = await Promise.all(summaries.map(summary => fetchEmbeddings(summary.title)));

            for (let i = 0; i < summaries.length; i++) {
                const similarity = cosineSimilarity(searchTermEmbedding, titleEmbeddings[i]);
                summaries[i].relevanceScore = similarity;
            }

            return summaries;
        }


        const nodeTag = document.getElementById("node-tag").value;
        const refTag = document.getElementById("ref-tag").value;

        const zettelkastenPrompt = `You are an ai whos responses are being visualized within a fractal mind-map which serves as the cognitive architecture for storing and searching your memories. The website is called Neurite.
                  - Follow the node reference tag format. This format is what enables you to connect ideas in a way that is visualized to the user.
Use the below style guidelines to format your response. Do not include the following instructions in your response to the user:
Remember, always use the format below to style your responses.

                        Prompt: Create a single node which describes how to create nodes.

                        Format:
                        ${nodeTag} (insert a unique, relevant, and descriptive node title)
                           - Write the plain text response below the node title in any style
                           - Provide a clear, concise, and explanation of a key idea, then move on to defining the references for that idea, then move on to creating new nodes. This will result in your response breaking up into multiple nodes.
                           - Instaed of replying with single node to represent your thought, break your response up into multiple connected nodes that represent your chain of thought.
                           - for example, you can represent a dialogue by having the titles for each node represent a character, and the plain text could be an instance of their dialogue.

                        ${refTag} (to connect nodes, print the exact titles of nodes to connect to this node seperated by commas)
                           - Connect the response to other related nodes using reference tags. If the user asks for certain nodes to be connected, make sure the proper ref tags are included to connect your response to the specified nodes.
                           - Use the exact node titles of the related nodes for reference tags.

                        Example:

                        Prompt
                        Create a triangle.

                        ${nodeTag} Point 1
                        This is the first point in our triangle.
                        ${refTag}

                        ${nodeTag} Point 2
                        This point is second.
                        ${refTag} title1

                        ${nodeTag} Point 3
                        You can say anything here relevant to the user memssage. Make sure not to overfill the plain text. Instead, chunk you ideas into relevant node structures.
                        ${refTag} title2, title 1 //take note of how circles could be made in the same way.

                        Efficiently condense the most salient ideas into a response that contructs a chain of-thought reasoning within the node reference tag format described above. This is a system prompt`;


        const spatialAwarenessExample = `${nodeTag} Central Node
- This is the central node from which other nodes branch out.
${refTag} Node A, Node B

${nodeTag} Node A
- This node is directly connected to the Central Node and branches out to Node C and Node D.
${refTag} Central Node, Node C, Node D

${nodeTag} Node B
- This node branches out from the Central Node to Node E and Node F.
${refTag} Central Node, Node E, Node F

${nodeTag} Node C
- This node is an end point, stemming from Node A.
${refTag} Node A

${nodeTag} Node D
- This node is an end point, stemming from Node A.
${refTag} Node A

${nodeTag} Node E
- This node is an end point, stemming from Node B.
${refTag} Node B

${nodeTag} Node F
- This node is an end point, stemming from Node B.
${refTag} Node B`;

        let summarizedZettelkastenPrompt = "";

        async function summarizeZettelkastenPrompt(zettelkastenPrompt) {
            const summarizedPromptMessages = [{
                role: "system",
                content: `zettelkastenPrompt ${zettelkastenPrompt}`,
            },
            {
                role: "system",
                content: `spatialAwarenessExample ${spatialAwarenessExample}`,
            },
            {
                role: "user",
                content: `Do not preface your response. Based on your understanding of the Fractal mind-map, tagging format, and the spatial awareness example which utilizes the format, create an advanced and concise example that utilizes the Zettelkasten format and interconnects nodes to best inform an ai how to utilize the described Zettelkasten prompt. Write your entire response within the format. Its important to make sure to keep your response under about 200 tokens. Your example should use 6 nodes total. Each node should break the response into a chain of thought reasoning that includes all relevant information to inform an ai system about proper use of the format. Adress your response to a fellow ai system.`,
            },
            ];

            return await callChatGPTApi(summarizedPromptMessages);
        }

        let isZettelkastenPromptSent = false;

        // Check if the user's message is a URL
        const isUrl = (text) => {
            try {
                new URL(text);
                return true;
            } catch (_) {
                return false;
            }
        }

        let MAX_CHUNK_SIZE = 400;

        const maxChunkSizeSlider = document.getElementById('maxChunkSizeSlider');
        const maxChunkSizeValue = document.getElementById('maxChunkSizeValue');

        // Display the initial slider value
        maxChunkSizeValue.textContent = maxChunkSizeSlider.value;

        // Update the current slider value (each time you drag the slider handle)
        maxChunkSizeSlider.oninput = function () {
            MAX_CHUNK_SIZE = this.value;
            maxChunkSizeValue.textContent = this.value;
        }

        let topN = 5;
        const topNSlider = document.getElementById('topNSlider');
        const topNValue = document.getElementById('topNValue');

        topNSlider.addEventListener('input', function () {
            topN = this.value;
            topNValue.textContent = this.value;
        });


        let isFirstMessage = true; // Initial value set to true
        let originalUserMessage = null;

        async function handleAutoMode() {
            const lastMessage = getLastPromptsAndResponses(1, 400);
            //console.log("Last message: ", lastMessage); // Debugging line

            // Use promptToUse if lastMessage doesn't contain the AI-generated prompt.
            const promptRegex = /prompt:\s*(.*)/i;
            const match = promptRegex.exec(lastMessage);

            if (match) {
                const aiGeneratedPrompt = match[1].trim();
                //console.log("AI generated prompt: ", aiGeneratedPrompt); // Debugging line
                return aiGeneratedPrompt;
            } else {
                console.error("AI-generated prompt not found in the last message.");
                return promptToUse;
            }
        }


        async function sendMessage(event, autoModeMessage = null) {
            const isAutoModeEnabled = document.getElementById("auto-mode-checkbox").checked;
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            const message = autoModeMessage ? autoModeMessage : document.getElementById("prompt").value;
            document.getElementById("prompt").value = ''; // Clear the textarea
            latestUserMessage = message;




            let wolframAlphaResult = "not-enabled";
            let wolframAlphaTextResult = "";
            let reformulatedQuery = "";


            if (autoModeMessage) {
                context = getLastPromptsAndResponses(2, 200);
            } else {
                if (document.getElementById("instructions-checkbox").checked) {
                    context = getLastPromptsAndResponses(1, 200);
                } else {
                    context = getLastPromptsAndResponses(3, 200);
                }
            }


            if (document.getElementById("enable-wolfram-alpha").checked) {
                // First call to ChatGPT to get a reformulated query
                reformulatedQuery = await callChatGPTApi([{
                    role: "system",
                    content: "Your role is to generate Wolfram Alpha compatible code, template, or a plain queries based on the current user message. Only include valid search queries with no preface or explanation. Create a search which is most probable to return a result from Wolfram. Make sure you are generating Wolfram code which is most specific to the current user message. The generated code should be specific, focused, and capable of returning relevant and accurate information to answer the user's question via a Wolfram Alpha query. Your goal is to provide the most relevant Wolfram code that directly addresses the user's inquiry. Remember, the user cannot see your responses, you are interacting with Wolfram Alpha. Make sure you response only includes content that can be directly searched in Wolfram Alpha without preface, labeling, or further explanation. Some examples include: D[x^3, x] for the derivative of x^3, N[Pi, 10] for the numerical value of Pi to 10 decimal places, or Integrate[Sin[x], x] for the integral of sin(x) dx. Provide a single line of Wolfram Alpha compatible code without any additional explanation or context. If you're unsure about the user query, provide your own example as a general alternative that is likely to return a result from Wolfram. Ensure that the code you generate is the most relevant and accurate for addressing the user's specific question. Make sure you response only includes a search to Wolfram Alpha witouth any extra tags or explanation. If the user has already input valid wolfram code, just reprint their exact code with no other addendum. If the user is vague, make sure you response still includes a valid Wolfram query. All your of your output should simulate a query to Wolfram Alpha with no other explnation attatched. Any response other than valid Wolfram Code will produce an error."
                },
                {
                    role: "user",
                    content: `${message} Wolfram Query`,
                }
                ]);
                console.log("Reformulated query:", reformulatedQuery);

                // Call Wolfram Alpha API with the reformulated query
                const apiKey = document.getElementById("wolframApiKey").value;

                const response = await fetch("http://localhost:3000", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        query: reformulatedQuery,
                        apiKey: apiKey
                    }),
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log("Wolfram Alpha data:", data); // Debugging data object

                    if (data.pods) {
                        const table = document.createElement("table");
                        table.style = "width: 100%; border-collapse: collapse;";

                        for (const pod of data.pods) {
                            const row = document.createElement("tr");

                            const titleCell = document.createElement("td");
                            titleCell.textContent = pod.title;
                            titleCell.style = "padding: 10px; background-color: #222226;";

                            const imageCell = document.createElement("td");
                            imageCell.style = "padding: 10px; text-align: center; background-color: white";

                            for (let i = 0; i < pod.images.length; i++) {
                                const imageUrl = pod.images[i];
                                const plaintext = pod.plaintexts[i];

                                // Adding plaintext to wolframAlphaTextResult
                                wolframAlphaTextResult += `${pod.title}: ${plaintext}\n`;

                                const img = document.createElement("img");
                                img.alt = `${reformulatedQuery} - ${pod.title}`;
                                img.style = "display: block; margin: auto; border: none;";
                                img.src = imageUrl;

                                imageCell.appendChild(img);
                            }

                            row.appendChild(titleCell);
                            row.appendChild(imageCell);
                            table.appendChild(row);
                        }

                        let content = [table];
                        let scale = 1; // You can adjust the scale as needed

                        let node = windowify(`${reformulatedQuery} - Wolfram Alpha Result`, content, toZ(mousePos), (zoom.mag2() ** settings.zoomContentExp), scale);
                        htmlnodes_parent.appendChild(node.content);
                        registernode(node);
                        node.followingMouse = 1;
                        node.draw();
                        node.mouseAnchor = toDZ(new vec2(0, -node.content.offsetHeight / 2 + 6));
                    }
                } else {
                    const errorData = await response.json();
                    console.error("Error with Wolfram Alpha API call:", errorData.error);
                    console.error("Full error object:", errorData);
                    alert("An error occurred when making a request the Wolfram Alpha. Please ensure the Wolfram server is running on your localhost with a valid Wolfram API key. The API input is in the Ai tab. Localhosts can be found at the Github link in the ? tab.");
                }
            } else {
                console.log("Wolfram Alpha is not enabled");
            }

            if (isAutoModeEnabled && originalUserMessage === null) {
                originalUserMessage = message;
            }

            // Convert nodes object to an array of nodes
            const nodesArray = Object.values(nodes);

            let keywordsArray = [];
            let keywords = '';
            let topMatchedNodesContent = [];

            if (!document.getElementById("code-checkbox").checked &&
                !document.getElementById("instructions-checkbox").checked &&
                !isUrl(message)) {
                // Call generateKeywords function to get keywords
                const count = 3; // Change the count value as needed
                keywordsArray = await generateKeywords(message, count);

                // Join the keywords array into a single string
                keywords = keywordsArray.join(' ');

                // Use the embeddedSearch function to find the top 3 matched nodes based on the keywords
                clearSearchHighlights(nodesArray); // Clear previous search highlights
                const topMatchedNodes = (await embeddedSearch(keywords, nodesArray)).slice(0, 3); //line 3831
                for (const node of topMatchedNodes) {
                    node.content.classList.add("search_matched");
                }
                console.log("Top Matched Nodes:", topMatchedNodes);

                // Extract the content of the top matched nodes and pass it as context to the AI
                topMatchedNodesContent = topMatchedNodes
                    .map((node) => {
                        if (!node) {
                            return "No relevant node found.";
                        }

                        const titleElement = node.content.querySelector("input.title-input");
                        const title = titleElement ? titleElement.value : "No title found";
                        // console.log("Title:", title);

                        const contentWrapper = node.content.querySelector("div.content");
                        const contentElement = contentWrapper ? contentWrapper.querySelector("textarea") : null;
                        const content = contentElement ? contentElement.value : "No content found";
                        // console.log("Content:", content);

                        //     const connectedNodesInfo = node.edges
                        //    ? node.edges.map((edge) => {
                        //         if (edge.nodeA && edge.nodeB) {
                        //              const connectedNode = edge.nodeA.uuid === node.uuid ? edge.nodeB : edge.nodeA;
                        //              return `Connected Node Title: ${connectedNode.uuid}\nConnected Node UUID: ${connectedNode.uuid ?? "N/A"
                        //                  }\nConnected Node Position: (${connectedNode.pos.x}, ${connectedNode.pos.y})`;
                        //          } else {
                        //              return ''; // Return an empty string or a placeholder message if connectedNode is undefined
                        //           }
                        //       }).join("\n")
                        //          : '';
                        //
                        //      const edgeInfo = node.edges
                        //           .map((edge) => {
                        //               if (edge.nodeA && edge.nodeB) {
                        //                   return `Edge Length: ${edge.length}\nEdge Strength: ${edge.strength}\nConnected Nodes UUIDs: ${edge.nodeA.uuid}, ${edge.nodeB.uuid}`;
                        //               } else {
                        //                   return ''; // Return an empty string or a placeholder message if connectedNode is undefined
                        //               }
                        //           }).join("\n");

                        const createdAt = node.createdAt;

                        return `Node UUID: ${node.uuid}\nNode Title: ${title}\nNode Content: ${content}\nNode Creation Time: ${createdAt}`; //\n\nConnected Nodes Info:\n${connectedNodesInfo}\n\nEdge Info:\n${edgeInfo}
                    })
                    .join("\n\n");
                //console.log("Top Matched Nodes Content:", topMatchedNodesContent);
            }
            const noteInput = document.getElementById("note-input");

            // Check if the last character in the note-input is not a newline, and add one if needed
            if (noteInput.value.length > 0 && noteInput.value[noteInput.value.length - 1] !== '\n') {
                noteInput.value += "\n";
            }

            // Add the user prompt and a newline only if it's the first message in auto mode or not in auto mode
            if (!autoModeMessage || (isFirstMessage && autoModeMessage)) {
                noteInput.value += `\nPrompt: ${message}\n\n`;
            }


            // Assuming you have the keywords array from the generateKeywords function
            const keywordString = keywords.replace("Keywords: ", "");
            const splitKeywords = keywordString.split(',').map(k => k.trim());
            const firstKeyword = splitKeywords[0];
            //  console.log("split?", splitKeywords[0])
            //console.log("first keyword", firstKeyword)
            console.log("keywords", keywords)
            //    console.log("keywords[0]", keywords[0])

            if (isWikipediaEnabled()) {
                const wikipediaSummaries = await getWikipediaSummaries(keywordsArray);
                // Use the summaries as needed
            }

            // Convert the keywords string into an array by splitting on spaces


            let wikipediaSummaries;

            if (isWikipediaEnabled()) {
                wikipediaSummaries = await getWikipediaSummaries([firstKeyword]);
            } else {
                wikipediaSummaries = "Wiki Disabled";
            }

            console.log("wikipediasummaries", wikipediaSummaries);
            //console.log("Keywords array:", keywords);

            const wikipediaMessage = {
                role: "system",
                content: `Wikipedia Summaries (Keywords: ${keywords}): \n ${Array.isArray(wikipediaSummaries)
                    ? wikipediaSummaries
                        .filter(s => s !== undefined && s.title !== undefined && s.summary !== undefined)
                        .map(s => s.title + " (Relevance Score: " + s.relevanceScore.toFixed(2) + "): " + s.summary)
                        .join("\n\n")
                    : "Wiki Disabled"
                    } END OF SUMMARIES`
            };

            // In your main function, check if searchQuery is null before proceeding with the Google search
            const searchQuery = await constructSearchQuery(message);
            if (searchQuery === null) {
                return; // Return early if a link node was created directly
            }

            let searchResultsData = null;
            let searchResults = [];

            if (isGoogleSearchEnabled()) {
                searchResultsData = await performSearch(searchQuery);
            }

            if (searchResultsData) {
                searchResults = processSearchResults(searchResultsData);
                searchResults = await getRelevantSearchResults(message, searchResults);
            }

            displaySearchResults(searchResults);

            const searchResultsContent = searchResults.map((result, index) => {
                return `Search Result ${index + 1}: ${result.title} - ${result.description.substring(0, 100)}...\n[Link: ${result.link}]\n`;
            }).join('\n');

            const googleSearchMessage = {
                role: "system",
                content: "The following Google Search Results have been displayed to the user:\n" + searchResultsContent + "\nEND OF SEARCH RESULTS \n Always remember to follow the system context message which describes the format of your response."
            };


            const embedCheckbox = document.getElementById("embed-checkbox");

            const codeMessage = {
                role: "system",
                content: `The "Code Checkbox = true" signifies that your response should include either Html/js or Python code that will be handled by Pyodide in the browser. Users can render plain text within each node as HTML in an iframe or Python in Pyodide. The instructions below guide your response:
${nodeTag}Unique Explanation Title (always use a unique title for each node rather than repeating these example titles)
Before writing your primary code response, provide a concise explanation of what you will accomplish with the code. Either html/js or Python
Step 1. Explantion preface
Step 2. Seperate node for an entire code block.
Provide a single code block rather than breaking the code into multiple sections.
Step 3. Final explanation of what the code accomplishes in node seperate from the code block.
Only your explanations should be chunked into seperate nodes. The code response should be a single node.
${nodeTag} Unique HTML/JS Response title specific to the code. ( HTML codeblock) If HTML response = No Python! Default to HTML unless asked for Python
For generating HTML and JavaScript responses:
- Structure your HTML correctly with appropriate head and body tags.
- The HTML will render in an iframe... Be sure to set the canvas size in the HTML as opposed to the JS.
- Enclose any JavaScript within a script tag rather than an external file.
- Be aware that more complex JavaScript code, particularly involving async operations or requestAnimationFrame, might not work as expected in the iframe environment. If your script involves such operations, consider alternatives or workarounds like using setInterval or wrapping your code in a 'DOMContentLoaded' event.
- Your JavaScript code will be run within the iframe scope, and won't have access to the parent page DOM or JavaScript context.
- Always remember to properly close HTML tags and handle potential JavaScript exceptions to avoid unexpected behavior or script failure.
- If your HTML/JS response includes CSS, be sure to encapsulate it properly within style tags in the head section.

ensure seperation of your code from your explanation using a unique title for each node.

${nodeTag} Unique Python Response title specific to the code. Assume the user is asking for Python code that outputs to Pyodide unless they specify to strictly write Python code that runs outside of Pyodide.
For generating Python responses in a Pyodide environment:

Always write code that will display correctly in Pyodide.
- The available libraries in the current Pyodide session are numpy, pandas, matplotlib, scipy, py, sympy, networkx. Stick to these libraries.
- When your Python code generates a visual output like plots or graphs, do NOT use plt.show(). Instead, save the figure to an in-memory binary stream, convert the image into a base64 string, and return this base64 string as an HTML img tag.
- Always use base64 and io to convert images into a base64 string for display.
- File operations and system calls are unsupported in Pyodide. Avoid using them.
- Handle potential exceptions by wrapping your code in try/except blocks due to Pyodide's limitations.
- Pyodide captures the last expression in the Python code, not what's printed to the console. Therefore, DO NOT rely on print statements to display results. Make sure to RETURN the result as the last expression in your Python code.
- For non-visual outputs, convert them into a string and Pyodide will include this directly within an HTML paragraph tag. If you're working with more complex data, convert it to a JSON string or an HTML table before returning it.
- Always label your code blocks with 'python' to clearly indicate that it's Python code. This will help others understand the context.
Remember: The key is to return the result, not print it. Pyodide can only capture the returned result.
${nodeTag} Unique Explanation Node (always use a unique title for each node rather than repeating these example titles)
Provide a clear explanation of the Python or HTML code and its output. Align the explanation with the Python code steps and avoid repetition. Ensure that your entire response, including code and explanation, is self-contained and does not rely on external files or data unless they are created within the code itself.`
            };

            const instructionsMessage = {
                role: "system",
                content: `The How-to checkbox is on. Please explain the fractal mind map implementation:
${nodeTag} Essential Controls:
- Drag to move; Scroll to zoom; Alt + Scroll to rotate; Alt + Click to resize multiple nodes.
- Shift + Double Click within Mandelbrot set rendering to create a text node.
- Hold shift for 'Node Mode', freezing time for node interaction.
- Shift + Scroll on a window's edge to resize.
- Shift + click on two nodes to link; Shift + Double Click on links to delete.
- Double Click a node to anchor/unanchor.
- Drag and drop multimedia files into the fractal to create nodes.
- Embed iframes by pasting links.

${nodeTag} Zettelkasten:
- Type notes in main text area using ${nodeTag} and ${refTag} (node reference tag) format.
- Save/Load notes in the settings tab or by copying and pasting main text area's content.

${nodeTag} Advanced Controls:
- Checkboxes below main text area provide additional features.
- API key setup needed for Open-Ai, Google Search, and Wolfram Alpha. OpenAI, Google Programable Search, and Wolfram API key inputs are in the Ai tab. LocalHost servers required for Extracts, Wolfram, and Wiki. Instructions are in Github link at the ? tab.
- Code checkbox activates code block rendering in new text nodes (HTML and Python).
- Search checkbox displays relevant webpages or pdfs. Requires Google Search API key unless a direct link is input as your prompt. Direct link entry bypasses google search api key requirement.
- Extract button on webpage/pdf nodes sends text to vector embeddings database Requires extracts localhost server.
- Extract checkbox sends the relevant chunks of text from the extracted webpage as context to the ai.
- Wolfram checkbox displays relevant Wolfram Alpha results. Requires Wolfram localhost server.
- Wiki checkbox displays relevant Wikipedia results. Requires Wiki localhost server.
- Auto checkbox sets the AI into self-prompting mode.

Make sure to exclusivly reference the above described controls. Try not to make anything up which is not explained in the above instructions.`
            };

            let messages = [{
                role: "system",
                content: `Your responses are being output to Neurite, a fractal cognitive architecture. Try not to repeat system messages to the user. Respond in the way most probable to match this description and example of the correct format.\n ${!isZettelkastenPromptSent ? zettelkastenPrompt : summarizedZettelkastenPrompt} \n Avoid repeating the above format context message.`,
            },
            {
                role: "system",
                content: `Recent dialogue if available. Empty on start of conversation. Continue in the same format. \n ${context}`,
            },
            autoModeMessage ?
                {
                    role: "user",
                    content: `Your self-prompt: ${autoModeMessage} \n
                    Original prompt: ${originalUserMessage}\n
                    Example of the desired format for your response with up to date node and reference tags.
                    ${nodeTag} Unique title \n
                    plain text on the next line for your response. \n
                    ${refTag} Titles of other nodes separated by commas.\n
                    ${nodeTag} Example \n
                    Break your response up into multiple nodes \n
                    Evaluate your previous response and build of the most correct nodes. \n
                    Never reference the instructions for the format of your response unless asked. \n
                        ${refTag} Repeat titles to connect nodes. \n
                    Always end your response with a new line, then, Prompt: [the prompt to continue the conversation (consider if the original goal has been accomplished while also progressing the conversation in new directions)]`,
                } :
                {
                    role: "user",
                    content: `User Message: ${message} \n
                    Example of the desired format for your response with up to date node and reference tags.
                    ${nodeTag} Unique Title \n
                    plain text on the next line for your response. \n
                    ${refTag} Titles of other nodes separated by commas.\n
                    ${nodeTag} Example \n
                    Break your response up into multiple nodes \n
                    Evaluate your previous response and build of the most correct nodes. \n
                    Never reference the instructions for the format of your response unless asked. \n
                        ${refTag} Repeat titles to connect nodes. \n
                    ${isAutoModeEnabled ? "Always end your response with a new line, then, Prompt: [the prompt to continue the conversation]" : ""}`,
                },
            ];



            if (document.getElementById("instructions-checkbox").checked) {
                messages.push(instructionsMessage);
            }

            if (!document.getElementById("code-checkbox").checked && !document.getElementById("instructions-checkbox").checked) {
                messages.splice(1, 0, {
                    role: "system",
                    content: `These nodes have been retrieved from your memory which is a fractal mind map \nConent: = what node says/plain text\n.${topMatchedNodesContent}`,
                });
            }


            if (document.getElementById("code-checkbox").checked) {
                messages.push(codeMessage);
            }

            if (document.getElementById("wiki-checkbox").checked) {
                messages.push(wikipediaMessage);
            }

            if (document.getElementById("google-search-checkbox").checked) {
                messages.push(googleSearchMessage);
            }




            if (embedCheckbox && embedCheckbox.checked) {
                const aiSuggestedSearch = await constructSearchQuery(message);

                // Replace topN = 5; with the slider value
                const relevantChunks = await getRelevantChunks(aiSuggestedSearch, searchResults, topN, false);

                // Group the chunks by their source (stripping the chunk number from the key)
                const groupedChunks = relevantChunks.reduce((acc, chunk) => {
                    // Separate the source and the chunk number
                    const [source, chunkNumber] = chunk.source.split('_chunk_');
                    if (!acc[source]) acc[source] = [];
                    acc[source].push({
                        text: chunk.text.substring(0, MAX_CHUNK_SIZE),
                        number: chunkNumber,
                        relevanceScore: chunk.relevanceScore,
                    });
                    return acc;
                }, {});

                // Construct the topNChunksContent
                const topNChunksContent = Object.entries(groupedChunks).map(([source, chunks]) => {
                    const chunksContent = chunks.map((chunk, index) => `Chunk ${index + 1}_${chunk.number} (Relevance: ${chunk.relevanceScore.toFixed(2)}): ${chunk.text}...`).join('\n');
                    return `[Source: ${source}]\n${chunksContent}\n`;
                }).join('\n');

                const embedMessage = {
                    role: "system",
                    content: `The following are the top ${topN} matched snippets of text from currently extracted webpages:\n Provide relevant information from the chunks as well as the respective source url.\n` + topNChunksContent + `\n Remember your system context message which describes the required format of your response.`
                };

                messages.push(embedMessage);
            }

            if (document.getElementById("enable-wolfram-alpha").checked) {
                const wolframAlphaMessage = {
                    role: "system",
                    content: `Wolfram Alpha Result: ${wolframAlphaTextResult}`
                };
                console.log("wolframAlphaTextResult:", wolframAlphaTextResult);
                messages.push(wolframAlphaMessage);
            }

            async function performSearch(searchQuery) {
                // Get the API Key and Search Engine ID from local storage
                const apiKey = localStorage.getItem('googleApiKey');
                const searchEngineId = localStorage.getItem('googleSearchEngineId');

                const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${searchEngineId}&q=${encodeURIComponent(searchQuery)}`;

                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    return data;
                } catch (error) {
                    console.error('Error fetching search results:', error);
                    alert('Failed to fetch search results. Please ensure you have entered your Google Programmable Search API key and search engine ID in the Ai tab.');
                    return null;
                }
            }

            const stream = true;

            // Main AI call
            if (stream) {
                await callChatGPTApi(messages, stream);
            } else {
                let aiResponse = await callChatGPTApi(messages, stream);

                if (aiResponse) {
                    const noteInput = document.getElementById("note-input");
                    if (noteInput.value[noteInput.value.length - 1] !== '\n') {
                        noteInput.value += "\n";
                    }
                    noteInput.value += aiResponse + "\n";
                } else {
                    console.error('AI response was undefined');
                }
            }

            // Only continue if shouldContinue flag is true
            if (shouldContinue) {
                // Handle auto mode
                if (isAutoModeEnabled && shouldContinue) {
                    // If the summarized prompt has not been generated yet, use the original zettelkasten prompt
                    let zettelkastenPromptToUse = summarizedZettelkastenPrompt !== "" ? summarizedZettelkastenPrompt : zettelkastenPrompt;
                    const aiGeneratedPrompt = await handleAutoMode(zettelkastenPromptToUse);
                    sendMessage(null, aiGeneratedPrompt);
                }

                // Check if the Zettelkasten prompt should be sent
                if (!isZettelkastenPromptSent && summarizedZettelkastenPrompt === "" && shouldContinue) {
                    // Update the isZettelkastenPromptSent flag after sending the zettelkasten prompt for the first time
                    isZettelkastenPromptSent = true;
                    // Generate the summarizedZettelkastenPrompt after the main AI call has completed
                    summarizedZettelkastenPrompt = await summarizeZettelkastenPrompt(zettelkastenPrompt);
                }
            }

            return false;
        }
        // console.log("Sending context to AI:", messages);

        async function constructSearchQuery(userMessage) {
            const embedCheckbox = document.getElementById("embed-checkbox");
            if (!isGoogleSearchEnabled() && (!embedCheckbox || !embedCheckbox.checked)) {
                return "not-enabled"; // Return an empty string or any default value when search is disabled
            }

            // If the user's message is a URL, use it as the search query and create a link node
            if (isUrl(userMessage)) {
                createLinkNode("User provided link", userMessage, userMessage);
                return null; // Return null to indicate that no further processing is necessary
            }

            recentcontext = getLastPromptsAndResponses(1, 200);

            // Rest of your code, if user's input is not a URL
            const queryContext = [{
                role: "system",
                content: `The following recent conversation may provide further context for generating your search query. \n ${recentcontext},`
            },
            {
                role: "system",
                content: "Construct search queries based on user prompts... Provide a search for the current user message. Keep in mind your response will be used both as a google search and as an embedded search for finding relevant chunks of webpage/pdf text. The user can not see your output. Only provide a single search query most probable to result in wepages relevant to the user query. Do not preface or explain your output. Consider any necessary terms that are necessary for the request.",
            },
            {
                role: "user",
                content: userMessage,
            },
            ];

            const searchQuery = await callChatGPTApi(queryContext);
            return searchQuery;
        }


        //ENDOFAI


        async function getRelevantSearchResults(userMessage, searchResults, topN = 5) {
            const userMessageEmbedding = await fetchEmbeddings(userMessage);

            // Get the embeddings for the search results and store them in an array
            const searchResultEmbeddings = await Promise.all(
                searchResults.map(async result => {
                    const titleAndDescription = result.title + " " + result.description;
                    const embedding = await fetchEmbeddings(titleAndDescription);
                    return {
                        result,
                        embedding
                    };
                })
            );

            // Calculate the cosine similarity between the user message embedding and each search result embedding
            searchResultEmbeddings.forEach(resultEmbedding => {
                resultEmbedding.similarity = cosineSimilarity(userMessageEmbedding, resultEmbedding.embedding);
            });

            // Sort the search results by their similarity scores
            searchResultEmbeddings.sort((a, b) => b.similarity - a.similarity);

            // Return the top N search results
            return searchResultEmbeddings.slice(0, topN).map(resultEmbedding => resultEmbedding.result);
        }



        //SEARCHAPI



        function isGoogleSearchEnabled() {
            const googleSearchCheckbox = document.getElementById("google-search-checkbox");
            return googleSearchCheckbox && googleSearchCheckbox.checked;
        }


        function processSearchResults(results) {
            if (!results || !results.items || !Array.isArray(results.items)) {
                return []; // Return an empty array if no valid results are found
            }

            const formattedResults = results.items.map(item => {
                return {
                    title: item.title,
                    link: item.link,
                    description: item.snippet
                };
            });

            if (!Array.isArray(formattedResults)) {
                return "No results found";
            }

            return formattedResults;
        }

        const CORS_PROXY = "http://localhost:4000/proxy";


        async function storeEmbeddingsAndChunksInDatabase(key, chunks, embeddings) {
            console.log(`Storing embeddings and text chunks for key: ${key}`);

            for (let i = 0; i < chunks.length; i++) {
                const chunkKey = `${key}_chunk_${i}`;
                await fetch('http://localhost:4000/store-embedding-and-text', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        key: chunkKey,
                        embedding: embeddings[i],
                        text: chunks[i]
                    }),
                });
            }
        }

        async function fetchAndStoreWebPageContent(url) {
            try {
                const response = await fetch(`${CORS_PROXY}?url=${encodeURIComponent(url)}`);

                if (!response.ok) {
                    console.error(`Failed to fetch web page content for ${url}:`, response.statusText);
                    return null;
                }

                const contentType = response.headers.get("content-type");
                const extractedTextResponse = await fetch(`${CORS_PROXY}/extract-text?url=${encodeURIComponent(url)}`);
                const text = await extractedTextResponse.text();

                if (typeof text !== "string") {
                    console.warn(`Text type for ${url}: ${contentType}`);
                    console.warn(`Text for ${url}:`, text);
                    return null;
                }

                const chunkedText = chunkText(text, MAX_CHUNK_SIZE);
                const chunkedEmbeddings = await fetchChunkedEmbeddings(chunkedText);

                // Store the chunked embeddings and text in the database
                await storeEmbeddingsAndChunksInDatabase(url, chunkedText, chunkedEmbeddings);
            } catch (error) {
                console.error(`Failed to fetch web page content for ${url}:`, error);
                alert("An error occurred fetching the top-n relevant chunks of extracted webpage text. Please ensure that the extract server is running on your localhost. Localhosts can be found at the Github link in the ? tab.");
                return null;
            }
        }

        async function fetchAllStoredEmbeddings() {
            try {
                const response = await fetch(`http://localhost:4000/fetch-all-embeddings`);

                if (!response.ok) {
                    console.error(`Failed to fetch stored embeddings:`, response.statusText);
                    return null;
                }

                // Parse the response text as JSON
                const embeddings = await response.json();
                //console.log('Fetched all stored embeddings:', embeddings);
                return embeddings;

            } catch (error) {
                console.error(`Failed to fetch stored embeddings:`, error);
                alert("An error occurred fetching the top-n relevant chunks of extracted webpage text. Please ensure that the extract server is running on your localhost. Localhosts can be found at the Github link in the ? tab.");
                return null;
            }
        }


        async function getRelevantChunks(searchQuery, searchResults) {
            const searchQueryEmbedding = await fetchEmbeddings(searchQuery);
            //console.log("Search query embedding:", searchQueryEmbedding);

            // Get all embeddings from the server
            const allEmbeddings = await fetchAllStoredEmbeddings();
            //console.log("All embeddings:", allEmbeddings);

            if (!allEmbeddings) {
                console.error("No embeddings were fetched. Please check the server logs for more information.");
                return [];
            }

            // Get the embeddings for the chunks and store them in an array
            const chunkEmbeddings = allEmbeddings.flatMap(embedding => {
                if (typeof embedding.chunks === 'string') {
                    const result = {
                        link: embedding.key,
                        description: embedding.chunks
                    };
                    return [{
                        result,
                        embedding: embedding.embedding
                    }];
                } else if (Array.isArray(embedding.chunks)) {
                    return embedding.chunks.map(chunk => {
                        const result = {
                            link: embedding.key,
                            description: chunk.text
                        };
                        return {
                            result,
                            embedding: chunk.embedding
                        };
                    });
                } else {
                    return [];
                }
            });
            //console.log("Chunk embeddings:", chunkEmbeddings);

            // Calculate the cosine similarity between the search query embedding and each chunk embedding
            chunkEmbeddings.forEach(chunkEmbedding => {
                chunkEmbedding.similarity = cosineSimilarity(
                    searchQueryEmbedding,
                    chunkEmbedding.embedding
                );
            });
            //console.log("Chunk embeddings with similarity:", chunkEmbeddings); //4551

            // Sort the chunks by their similarity scores
            chunkEmbeddings.sort((a, b) => b.similarity - a.similarity);
            console.log("Sorted chunk embeddings:", chunkEmbeddings);

            // Return the top N chunks
            const topNChunks = chunkEmbeddings
                .slice(0, topN)
                .map(chunkEmbedding => ({
                    text: chunkEmbedding.result.description,
                    source: chunkEmbedding.result.link,
                    relevanceScore: chunkEmbedding.similarity
                }));
            console.log("Top N Chunks:", topNChunks);

            return topNChunks;
        }

        function chunkText(text, maxLength) {
            const words = text.split(/\s+/);
            const chunks = [];
            let chunk = '';

            for (const word of words) {
                if ((chunk + word).length <= maxLength) {
                    chunk += ' ' + word;
                } else {
                    chunks.push(chunk.trim());
                    chunk = word;
                }
            }

            if (chunk) {
                chunks.push(chunk.trim());
            }

            return chunks;
        }

        async function fetchChunkedEmbeddings(textChunks, model = "text-embedding-ada-002") {
            const API_KEY = document.getElementById("api-key-input").value;
            if (!API_KEY) {
                alert("Please enter your API key");
                return;
            }

            const API_URL = "https://api.openai.com/v1/embeddings";

            const headers = new Headers();
            headers.append("Content-Type", "application/json");
            headers.append("Authorization", `Bearer ${API_KEY}`);

            const chunkEmbeddings = [];

            for (const chunk of textChunks) {
                const body = JSON.stringify({
                    model: model,
                    input: chunk,
                });

                const requestOptions = {
                    method: "POST",
                    headers: headers,
                    body: body,
                };

                try {
                    const response = await fetch(API_URL, requestOptions);
                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("Error fetching embeddings:", errorData);
                        chunkEmbeddings.push([]);
                        continue;
                    }

                    const data = await response.json();
                    const embedding = data.data[0].embedding;

                    chunkEmbeddings.push(embedding);
                } catch (error) {
                    console.error("Error fetching embeddings:", error);
                    chunkEmbeddings.push([]);
                }
            }

            return chunkEmbeddings;
        }

        function createLinkNode(name = '', text = '', link = '', sx = undefined, sy = undefined, x = undefined, y = undefined) {
            let t = document.createElement("input");
            t.setAttribute("type", "text");
            t.setAttribute("value", name);
            t.setAttribute("style", "background:none; ");
            t.classList.add("title-input");

            let a = document.createElement("a");
            a.setAttribute("href", link);
            a.setAttribute("target", "_blank");
            a.textContent = text;
            a.setAttribute("style", "display: block; padding: 10px; word-wrap: break-word; white-space: pre-wrap;");

            let linkWrapper = document.createElement("div");
            linkWrapper.style.width = "300px";
            linkWrapper.appendChild(a);

            let iframeWrapper = document.createElement("div");
            iframeWrapper.style.width = "100%";
            iframeWrapper.style.height = "0";
            iframeWrapper.style.flexGrow = "1";
            iframeWrapper.style.flexShrink = "1";
            iframeWrapper.style.display = "none";
            iframeWrapper.style.boxSizing = "border-box";

            let iframe = document.createElement("iframe");
            iframe.setAttribute("src", "");
            iframe.setAttribute("style", "width: 100%; height: 100%; border: none; overflow: auto;");

            iframe.addEventListener("load", () => {
                const buttonHeight = button.offsetHeight + displayButton.offsetHeight + extractButton.offsetHeight;
                const minHeight = iframe.offsetHeight + buttonHeight + 35;
                const currentHeight = parseInt(windowDiv.style.height, 10);

                if (currentHeight < minHeight) {
                    windowDiv.style.height = `${minHeight}px`;
                }
            });

            let button = document.createElement("button");
            button.textContent = "Load as iframe";
            button.classList.add("linkbuttons");

            button.addEventListener("click", () => {
                if (iframeWrapper.style.display === "none") {
                    iframeWrapper.appendChild(iframe);
                    linkWrapper.style.display = "none";
                    iframeWrapper.style.display = "block";
                    button.textContent = "Return to link";

                    // Set the src attribute of the iframe here
                    iframe.setAttribute("src", link);

                    // Adjust the height of the iframeWrapper to accommodate buttons
                    let availableHeight = windowDiv.offsetHeight - buttonsWrapper.offsetHeight;
                    iframeWrapper.style.height = availableHeight + 'px';
                } else {
                    linkWrapper.style.display = "block";
                    iframeWrapper.style.display = "none";
                    button.textContent = "Load as iframe";
                    // Clear the src attribute of the iframe here
                    iframe.setAttribute("src", "");
                }
            });

            let extractButton = document.createElement("button");
            extractButton.textContent = "Extract Text";
            extractButton.classList.add("linkbuttons");

            extractButton.addEventListener("click", function () {
                let dotCount = 0;

                // Start the dot animation
                const dotInterval = setInterval(() => {
                    dotCount = (dotCount + 1) % 4; // Cycle dotCount between 0 and 3
                    extractButton.textContent = "Extracting" + ".".repeat(dotCount);
                }, 500); // Update every 500 milliseconds

                setTimeout(async function () {
                    try {
                        // Send the link to the server for text extraction
                        const response = await fetch('http://localhost:4000/proxy?url=' + encodeURIComponent(link));

                        // Handle the server response
                        if (response.ok) {
                            const extractedText = await response.text();
                            console.log('Extracted text:', extractedText);

                            // Chunk the extracted text
                            const chunkedText = chunkText(extractedText, MAX_CHUNK_SIZE);

                            // Fetch embeddings for the chunked text
                            const chunkedEmbeddings = await fetchChunkedEmbeddings(chunkedText);

                            // Store the embeddings in the database along with the extracted text
                            await storeEmbeddingsAndChunksInDatabase(link, chunkedText, chunkedEmbeddings);

                            extractButton.textContent = "Extracted";
                        } else {
                            console.error('Failed to extract text:', response.statusText);
                            extractButton.textContent = "Extract Failed";
                            alert("Failed to connect to the local server. Please ensure that the extract server is running on your localhost. Localhosts can be found at the Github link in the ? tab.");
                        }
                    } catch (error) {
                        console.error('Error during extraction:', error);
                        extractButton.textContent = "Extract Failed";
                        alert("An error occurred during extraction. Please ensure that the extract server is running on your localhost. Localhosts can be found at the Github link in the ? tab.");
                    } finally {
                        // Stop the dot animation
                        clearInterval(dotInterval);
                    }
                }, 500);
            });

            let displayWrapper = document.createElement("div");
            displayWrapper.style.width = "100%";
            displayWrapper.style.height = "100%";
            displayWrapper.style.flexGrow = "1";
            displayWrapper.style.flexShrink = "1";
            displayWrapper.style.display = "none";
            displayWrapper.style.boxSizing = "border-box";

            let displayButton = document.createElement("button");
            displayButton.textContent = "Display Webpage";
            displayButton.classList.add("linkbuttons");

            displayButton.addEventListener("click", async function () {

                let displayIframe = displayWrapper.querySelector("iframe");

                if (displayIframe) {
                    displayIframe.remove();
                    displayButton.textContent = "Display Webpage";
                    displayWrapper.style.display = "none";
                    linkWrapper.style.display = "block";
                } else {
                    // Iframe does not exist, so fetch the webpage content and create it
                    const response = await fetch('http://localhost:4000/raw-proxy?url=' + encodeURIComponent(link));

                    if (response.ok) {
                        const webpageContent = await response.text();

                        displayIframe = document.createElement("iframe");
                        displayIframe.srcdoc = webpageContent;
                        displayIframe.style.width = "100%";
                        displayIframe.style.height = "100%";
                        displayIframe.style.overflow = "auto";

                        displayIframe.addEventListener("load", () => {
                            const buttonHeight = button.offsetHeight + displayButton.offsetHeight + extractButton.offsetHeight;
                            const minHeight = displayIframe.offsetHeight + buttonHeight + 35;
                            const currentHeight = parseInt(windowDiv.style.height, 10);

                            if (currentHeight < minHeight) {
                                windowDiv.style.height = `${minHeight}px`;
                            }
                        });

                        displayWrapper.appendChild(displayIframe);
                        displayButton.textContent = "Close Webpage";
                        displayWrapper.style.display = "block";
                        linkWrapper.style.display = "none";

                        let availableHeight = windowDiv.offsetHeight - buttonsWrapper.offsetHeight;
                        displayWrapper.style.height = availableHeight + 'px';
                    } else {
                        console.error('Failed to fetch webpage content:', response.statusText);
                        alert("An error occurred displaying the webpage through a proxy server. Please ensure that the extract server is running on your localhost. Localhosts can be found at the Github link in the ? tab.");
                    }
                }
            });


            let node = addNodeAtNaturalScale(name, []);
            let windowDiv = node.content.querySelector(".window");

            let buttonsWrapper = document.createElement("div");
            buttonsWrapper.classList.add("buttons-wrapper");
            buttonsWrapper.style.order = "1";
            buttonsWrapper.appendChild(button);
            buttonsWrapper.appendChild(displayButton);
            buttonsWrapper.appendChild(extractButton);

            let contentWrapper = document.createElement("div");
            contentWrapper.style.display = "flex";
            contentWrapper.style.flexDirection = "column";
            contentWrapper.style.alignItems = "center";
            contentWrapper.style.height = "100%";

            contentWrapper.appendChild(linkWrapper);
            contentWrapper.appendChild(iframeWrapper);
            contentWrapper.appendChild(displayWrapper);
            contentWrapper.appendChild(buttonsWrapper);

            windowDiv.appendChild(contentWrapper);

            let minWidth = Math.max(linkWrapper.offsetWidth, contentWrapper.offsetWidth) + 5;
            let minHeight = Math.max(linkWrapper.offsetHeight, contentWrapper.offsetHeight) + 35;
            windowDiv.style.width = minWidth + "px";
            windowDiv.style.height = minHeight + "px";

            // Initialize the resize observer
            observeContentResize(windowDiv, iframeWrapper, displayWrapper);

            return node;
        }

        function observeContentResize(windowDiv, iframeWrapper, displayWrapper) {
            const resizeObserver = new ResizeObserver((entries) => {
                for (let entry of entries) {
                    const {
                        width,
                        height
                    } = entry.contentRect;

                    // Find the buttonsWrapper inside windowDiv
                    const buttonsWrapper = windowDiv.querySelector(".buttons-wrapper");

                    if (buttonsWrapper) {
                        // Calculate the available height for the iframes
                        let buttonsHeight = buttonsWrapper.offsetHeight || 0;
                        let iframeHeight = Math.max(0, height - buttonsHeight - 50); // Subtract additional margin

                        // Update the width and height of iframeWrapper and displayWrapper
                        iframeWrapper.style.width = width + "px";
                        iframeWrapper.style.height = iframeHeight + "px";
                        displayWrapper.style.width = width + "px";
                        displayWrapper.style.height = iframeHeight + "px";
                    }
                }
            });

            resizeObserver.observe(windowDiv);
        }

        function createLinkElement(link, text) {
            const linkWrapper = document.createElement("div");
            linkWrapper.style.width = "300px";
            const a = document.createElement("a");
            a.setAttribute("href", link);
            a.setAttribute("target", "_blank");
            a.textContent = text;
            a.setAttribute("style", "display: block; padding: 10px; word-wrap: break-word; white-space: pre-wrap;");
            linkWrapper.appendChild(a);
            return linkWrapper;
        }

        function displaySearchResults(searchResults) {
            searchResults.forEach((result, index) => {
                let title = `Search Result ${index + 1}: ${result.title}`;
                let description = result.description.substring(0, 500) + "...";
                let link = result.link;

                let node = createLinkNode(title, description, link);

                htmlnodes_parent.appendChild(node.content);
                registernode(node);
                // Attach the node to the user's mouse
                node.followingMouse = 1;
                node.draw();
                node.mouseAnchor = toDZ(new vec2(0, -node.content.offsetHeight / 2 + 6));
            });
        }
    </script>
</body>

</html>
