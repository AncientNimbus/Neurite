<!DOCTYPE HTML>
<html>
<head>
  <title>Mandelbrott</title>
  <style type="text/css">
    html {
        /* overflow:hidden; */
    }
    body {
        margin: 0;
        padding: 0;
        background-color: #000000;
    }
  </style>
</head>

<body id="body">
  <div ondragover="dragOverHandler(event);" ondrop="dropHandler(event);">
    <svg id="svg_bg" viewBox="-4 -4 8 8" width="100%" height="100%" top="0" left="0" position="fixed">
      <title>Mandelbrott level sets</title>
      <a id="bg" />
      <path id="mousePath" d="" fill="none" stroke="red" stroke-width="0.01"/>
      <a id="edges"/>
    </svg>
  </div>

  
  <a id="link" href="https://www.example.com">Test Link</a>
  <svg id="svg_link" viewBox="0 0 240 80">
    <title>link test</title>
    <style>
      .small {
          font: italic 13px sans-serif;
          fill: white;
      }
      .heavy {
          font: bold 30px sans-serif;
          fill: white;
      }

      /* Note that the color of the text is set with the    *
       * fill property, the color property is for HTML only */
      .Rrrrr {
          font: italic 40px serif;
          fill: red;
      }
    </style>

    <text x="20" y="35" class="small">My</text>
    <text x="40" y="35" class="heavy">cat</text>
    <text x="55" y="55" class="small">is</text>
    <a href="example.com">
      <text x="65" y="55" class="Rrrrr">Grumpy!</text>
    </a>
  </svg>




  <a id="nodes">
    <!-- add stuff here -->

    
    <iframe id="inlineFrameExample"
            title="Inline Frame Example"
            width="150"
            height="100"
            src="https://m.media-amazon.com/images/M/MV5BOTY2NDY4OGUtYWE0Ni00NWZiLWI3NDktYmE2YWM3Njc3YmRkXkEyXkFqcGdeQXVyMTIxOTU1MjQ3._V1_.jpg">
    </iframe>
    <h6>Test</h6>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="red"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="orange"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="yellow"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="green"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="blue"/></svg>
    <svg width="20" height="20"><circle cx="10" cy="10" r="10" fill="purple"/></svg>
    
    <p>HEllo</p>
    
  </a>
  <script type="application/javascript">
    console.log("test");
    document.body.style.overflow = 'hidden';
    var svg = document.getElementById("svg_bg");
    
    class vec2{
        constructor(x,y) {this.x = x;this.y = y;}
        plus(o) {return new vec2(this.x+o.x,this.y+o.y);}
        minus(o) {return new vec2(this.x-o.x,this.y-o.y);}
        times(o) {return new vec2(this.x*o.x,this.y*o.y);}
        div(o) {return new vec2(this.x/o.x,this.y/o.y);}
        dot(o) {return this.x*o.x+this.y*o.y}
        cross(o) {return this.x*o.y-this.y*o.x}
        scale(s) {return new vec2(this.x*s,this.y*s);}
        unscale(s) {return new vec2(this.x/s,this.y/s);}
        normed(){return this.unscale(this.mag());}
        mag2() {return this.dot(this);}
        mag() {return Math.hypot(this.x,this.y);}
        ang() {return Math.atan2(this.y,this.x);}
        pang() {
            if (this.x == 0 && this.y == 0) {return 0;}
            let p = this.x/(Math.abs(this.x)+Math.abs(this.y));
            return this.y<0?p-1:1-p;
	}
	map(f) {return new vec2(f(this.x),f(this.y));}
        
        cadd(o) {return this.plus(o);}
        csub(o) {return this.minus(o);}
        cneg(o) {return new vec2(-this.x,-this.y);}
        cmult(o) {return new vec2(this.x*o.x-this.y*o.y,this.y*o.x+this.x*o.y);}
        caamult(o) {
            //angle averaging multiply?
            let s = this.plus(o);
            return s.scale(this.cmult(o).mag()/s.mag());
        }
        cconj() {return new vec2(this.x,-this.y);}
        crecip() {
            // 1/(a+bi) = (a-bi)/mag2
            return this.cconj().unscale(this.mag2());
        }
        cdiv(o) {return this.cmult(o.crecip());}
        cpow(o) {return this.clog().cmult(o).cexp();}
        
        cexp(){
            let m = Math.exp(this.x);
            let i = Math.sin(this.y);
            let r = Math.cos(this.y);
            return new vec2(m*r,m*i);
        }
        clog(){
            let r = Math.log(this.mag2())/2;//no sqrt because log rules
            let i = Math.atan2(this.y,this.x);
            return new vec2(r,i);
        }

        str(){
            return this.x+","+this.y;
        }
        sqrt(){
            //https://www.johndcook.com/blog/2020/06/09/complex-square-root/
            let l = this.mag();
            let u = Math.sqrt((l+this.x)/2);
            let v = Math.sign(this.y)*Math.sqrt((l-this.x)/2);
            return new vec2(u,v);
        }
    }
    function lerp(a,b,t){
	return a*(1-t)+b*t;
    }
    
    var mousePos = new vec2(0,0);
    var mousePath = "";

    var zoom = new vec2(4,0);//bigger is further out
    var pan = new vec2(0,0);
    
    function toZ(c){
        let s = window.innerWidth;//Math.hypot(window.innerHeight,window.innerWidth)/2**.5;
        return c.unscale(s).minus(new vec2(.5,.5)).scale(2).cmult(zoom).cadd(pan);
    }
    function toDZ(c){
        let s = window.innerWidth;//Math.hypot(window.innerHeight,window.innerWidth)/2**.5;
        return c.unscale(s).scale(2).cmult(zoom);
    }
    function fromZ(z){
        let s = window.innerWidth;//Math.hypot(window.innerHeight,window.innerWidth)/2**.5;
        return z.csub(pan).cdiv(zoom).unscale(2).plus(new vec2(.5,.5)).scale(s);
    }
    function fromZtoUV(z){
        return z.csub(pan).cdiv(zoom).unscale(2).plus(new vec2(.5,.5));
    }
    var SVGzoom = 8192;
    var SVGpan = new vec2(0,0);
    let recenterThreshold = 0.01;
    let rezoomThreshold = 0.01;
    function updateViewbox(){//todo fix when adding rotations
	let lc = toSVG(toZ(new vec2(0,0)));
	let d = zoom.mag()*2*SVGzoom;
	let recalc = false;
	if (d < Math.abs(recenterThreshold*lc.x) || d < Math.abs(recenterThreshold*lc.y)){
	    let oldPan = SVGpan;
	    SVGpan = pan.scale(1);
	    lc = toSVG(toZ(new vec2(0,0)));
	    console.log("recentering...");
	    recalc = true;
	}
	if (d < rezoomThreshold || d > 8192/rezoomThreshold){
	    SVGzoom *= 8192/d;
	    console.log("rezooming...");
	    recalc = true;
	}
	if (recalc){
	    recalc_svg();
	}
	svg.setAttribute("viewBox",lc.x+" "+lc.y+" "+d+" "+d);
	
    }
    function toSVG(coords){
	return coords.minus(SVGpan).scale(SVGzoom);
    }
    
    function recalc_svg(){
	//todo
	//placeholder:
	let node = svg.children[1];
	while (node.firstChild) {
	    node.removeChild(node.lastChild);
	}
    }
    
    
    
    
    
    document.getElementById("body").addEventListener("mousemove", (event) =>{
        mousePos.x = event.pageX;
        mousePos.y = event.pageY;
        mousePath = "";
    }, false);
    document.getElementById("body").addEventListener("mouseclick", (event) =>{
        mousePos.x = event.pageX;
        mousePos.y = event.pageY;
        /*let p = toZ(mousePos);
        zoom = zoom.unscale(2);
        pan = p;*/
    }, false);
    function mand_step(z,c){return z.cmult(z).cadd(c);}

    function mand_unstep(z,c){return z.csub(c).sqrt();}

    function mand_i(z,iters=16){
	let c = z;
	for (let i = 0; i < iters; i ++){
            if (z.mag2() > 4){
		return i;
            }
            z = mand_step(z,c);
        }
	return (z.mag2() > 4)? iters:iters+1;
    }
    
    function mandelbrott_dist(iters,c,z){
        if (z === undefined) { z = new vec2(0,0);}
        let pz = z;
        for (let i = 0; i < iters; i ++){
            if (z.mag2() > 4){
                let zm = z.mag();
                let pzm = pz.mag();
                return i + (2-pzm)/(zm-pzm);
            }
            pz = z;
            z = mand_step(z,c);
        }
        return iters;
    }
    function mandelbrott_dist(iters,c,z){
        let bailout = 1e8;//large so z^2+c -> z^2
        if (z === undefined) { z = new vec2(0,0);}
        let pz = z;
        for (let i = 0; i < iters; i ++){
            if (z.mag2() > bailout){
                //pz^2 = z
                //pz^(2^?) = b
                //ln(pz)2^?=ln(b)
                //ln(ln(pz))+ln(2)*?=ln(ln(b))
                let g = Math.log2(Math.log(bailout));
                let llz = Math.log2(Math.log2(z.mag2())/2);
                return i-llz;
            }
            pz = z;
            z = mand_step(z,c);
        }
        return iters;
    }
    function mandelbrott_grad(iters,c,z){
        let bailout = 1e8;//large so z^2+c -> z^2
        if (z === undefined) { z = new vec2(0,0);}
        let dz = new vec2(1,0);
        for (let i = 0; i < iters; i ++){
            if (z.mag2() > bailout){
                //pz^2 = z
                //pz^(2^?) = b
                //ln(pz)2^?=ln(b)
                //ln(ln(pz))+ln(2)*?=ln(ln(b))
                return dz;
                let llz = Math.log2(Math.log2(z.mag2())/2);
                return i-llz;
            }
            z = mand_step(z,c);
            dz = dz.cmult(z.scale(2));
        }
        return new vec2(0,0);
    }
    function mandGrad(maxIters,c,z){
        //return mandelbrott_grad(maxIters,c,z);
        let e = 1e-10;
        let d = mandelbrott_dist(maxIters,c,z);
        return new vec2(
            mandelbrott_dist(maxIters,c.plus(new vec2(e,0)),z)-d,
            mandelbrott_dist(maxIters,c.plus(new vec2(0,e)),z)-d
        ).unscale(e);
        
        //let re = 1.00000001;
        //let e = 1e-100;
        //if (z === undefined) { z = c;}
        //let d = mandelbrott_dist(maxIters,c,z);
        //let f = (v) => (Math.abs(v)<e?v+e:v*re);
        //let fz = new vec2(f(z.x),f(z.y));
        //return new vec2(
        //    mandelbrott_dist(maxIters,c,new vec2(fz.x,z.y))-d,
        //    mandelbrott_dist(maxIters,c,new vec2(z.x,fz.y))-d
        //    ).div(fz.minus(z)); 
    }
    function* trace_circle(iters,z0,step){
        if (step === undefined) { step = 0.5;}
        let level = mandelbrott_dist(iters,z0);
        let z = z0;
        while (true){
            yield z;
            let vz = mandelbrott_dist(iters,z);
            let gz = mandGrad(iters,z);
            z = z.plus(gz.cmult(new vec2(level-vz,step).unscale(gz.mag2())));
        }
    }
    function col(i){
	let r = nodeMode_v
	let rgb = [128-127*Math.cos(i/2**.5),128-127*Math.cos(i/3**.5),128-127*Math.cos(i/5**.5)];
	let y = 0.17697*rgb[0]+0.81240*rgb[1]+0.01063*rgb[2];
        return [lerp(rgb[0],y,nodeMode_v),lerp(rgb[1],y,nodeMode_v),lerp(rgb[2],y,nodeMode_v)];
    }
    function scol(i){
        let c = col(i);
        return "RGB("+Math.round(c[0])+","+Math.round(c[1])+","+Math.round(c[2])+")";
    }
    

    //let l = document.getElementById("link");
    //l.style.position="absolute";
    //l.style.left="100px";
    //l.style.top="100px";
    

    function outlineMand(start,step,iters){
        iters = iters===undefined?256:iters;
        step = step===undefined?0.1:step;
        let a0 = start.pang();
        let path = "M "+toSVG(start).str()+"\nL ";
        let pz = start;
        let maxlen = 1<<15;
        let minD2 = 0.25/200/200;
        for (let z of trace_circle(iters,start,step)){
            //if (z.minus(pz).mag2() < minD2){ continue;}
            if (z.pang() <= a0 && pz.pang() > a0){
                break;
            }
            maxlen --;
            if (maxlen <= 0){
                break;
            }
            path += toSVG(z).str()+" ";
            pz = z;
        }
        return path;
    }

    function addPath(path,stroke,fill){
        if (stroke === undefined) {stroke = "red"}
        if (fill === undefined) {stroke = "none"}
        let pathn = document.createElementNS("http://www.w3.org/2000/svg","path");
        pathn.setAttribute("fill",fill);
        pathn.setAttribute("stroke",stroke);
        pathn.setAttribute("d",path);
        svg.appendChild(pathn);
        return pathn;
    }

    function* iter(){
        for (let x = 8; x > 0.3; x *= 1-1/8){
            let pathn = document.createElementNS("http://www.w3.org/2000/svg","path");
            //pathn.setAttribute("fill",scol(mandelbrott_dist(1024,new vec2(x,0))));
	    pathn.setAttribute("fill","none");
            pathn.setAttribute("stroke",scol(mandelbrott_dist(1024,new vec2(x,0))));
	    pathn.setAttribute("stroke-width",""+(SVGzoom*0.01));
            pathn.setAttribute("d","");
            svg.children[1].appendChild(pathn);
            let start = new vec2(x,0);
            let a0 = start.pang();
            let l = (m)=>m;
            let path = "M "+toSVG(l(start)).str()+"\nL ";
            let pz = start;
            let maxlen = 1<<12;
            let minD2 = 0.01/200/200;
            for (let z of trace_circle(1024,start,0.1)){
                
                if (z.pang() <= a0 && pz.pang() > a0){
                    break;
                }
                maxlen --;
                if (maxlen <= 0){
                    pathn.setAttribute("d",path+" z");
                    yield;
                    maxlen = 1<<12;
                }
                if (z.minus(pz).mag2() < minD2){ continue;}
                path += toSVG(l(z)).str()+" ";
                pz = z;
            }
            pathn.setAttribute("d",path+" z");
            yield;
        }
    }
    function put(e,p,s=1){
	let svgbb = svg.getBoundingClientRect();
        e.style.position="absolute";
	e.style.transform = "scale("+s+","+s+")";
        p = fromZtoUV(p);
	p.x = svgbb.left + svgbb.width*p.x;
	p.y = svgbb.top + svgbb.height*p.y;
	let bb = e.getBoundingClientRect();
        p = p.minus(new vec2(bb.width,bb.height).scale(0.5/s));
        e.style.left = p.x+"px";
        e.style.top = p.y+"px";

        
        //e.style['margin-top'] = "-"+(e.offsetHeight/2)+"px";//"-50%";
        //e.style['margin-left'] = "-"+(e.offsetWidth/2)+"px";//"-50%";
        //e.style['vertical-align']= 'middle';
        //e.style['text-align']= 'center';
        
    }
    var movingNode = undefined;
    let prevNode = undefined;
    class Node{
        constructor(p,thing,scale=1){
            this.pos = (p !== undefined)?p: new vec2(0,0);
	    this.mouseAnchor = new vec2(0,0);
	    this.scale = scale;
            this.content = thing;
            this.vel = new vec2(0,0);
            this.force = new vec2(0,0);
            this.edges = [];
	    this.followingMouse = 0;
        }
	draw(){
	    put(this.content,this.pos,this.scale*(zoom.mag2()**-0.25));
	}
        step(dt){
            if (dt === undefined || isNaN(dt)){
                dt = 0;
            }else{
                if (dt > 1){
                    dt = 1;
                }
            }
	    if (!this.followingMouse){	
		this.pos = this.pos.plus(this.vel.scale(dt/2));
		this.vel = this.vel.plus(this.force.scale(dt));
		this.pos = this.pos.plus(this.vel.scale(dt/2));
		this.force = this.vel.scale(-Math.min(this.vel.mag()+0.4,1/(dt+1e-300)));
	    }else{
		this.vel = new vec2(0,0);
		this.force = new vec2(0,0);
	    }
            this.draw();
            let g = mandGrad(256,this.pos);
            //g.y *= -1; //why?
            this.force = this.force.plus(g.unscale((g.mag2()+1e-10)*300));
	    //let d = toZ(mousePos).minus(this.pos);
	    //this.force = this.force.plus(d.scale(this.followingMouse/(d.mag2()+1)));
	    if (this.followingMouse){
		this.pos = toZ(mousePos).minus(this.mouseAnchor);
	    }
            //this.force = this.force.plus((new vec2(-.1,-1.3)).minus(this.pos).scale(0.1));
        }
	onclick(event){
	    if (nodeMode){
		if (prevNode === undefined){
		    prevNode = this;
		}else{
		    connect(this,prevNode);
		    prevNode = undefined;
		}
	    }else{

	    }
	}
	onmousedown(event){
	    this.mouseAnchor = toZ(new vec2(event.clientX,event.clientY)).minus(this.pos);
	    this.followingMouse = 1;
	    movingNode = this;
	    cancel(event);
	}
	onmouseup(event){
	    this.followingMouse = 0;
	    if (this === movingNode){
		movingNode = undefined;
	    }
	    cancel(event);
	}
	onmousemove(event){
	    /*if (this.followingMouse){
		this.pos = this.pos.plus(toDZ(new vec2(event.movementX,event.movementY)));
		this.draw()
		cancel(event);
	    }*/
	}

    }
    let htmlnodes_parent = document.getElementById("nodes");
    let htmlnodes = htmlnodes_parent.children;
    let htmledges =  document.getElementById("edges")
    class Edge{
        constructor(pts,length=0.6,strength=0.1,style={stroke:"red","stroke-width":"0.01"}){
            this.pts = pts;
            this.length = length;
            this.strength = strength;
            this.style = style;
            this.html = document.createElementNS("http://www.w3.org/2000/svg","path");
            for (const [key, value] of Object.entries(style)) {
                this.html.setAttribute(key,value);
            }
            htmledges.appendChild(this.html);
        }
	stress(){
	    let avg = this.pts.reduce((t,n,i,a)=>
                {return t.plus(n.pos);},new vec2(0,0)).unscale(this.pts.length);
	    return this.pts.reduce((t,n,i,a)=>
                {return t+n.pos.minus(avg).mag();},0)/(this.length+1);
	}
        draw(){
	    this.html.setAttribute("stroke-width",this.style['stroke-width']*SVGzoom*zoom.mag()/(0.5+this.stress()));
            this.html.setAttribute("d","M "+this.pts.map((v)=>(toSVG(v.pos).str())).join(" L "));
        }
        step(dt){
            if (dt === undefined || isNaN(dt)){
                dt = 0;
            }else{
                if (dt > 1){
                    dt = 1;
                }
            }
            let avg = this.pts.reduce((t,n,i,a)=>
                {return t.plus(n.pos);},new vec2(0,0)).unscale(this.pts.length);
            for (let n of this.pts){
                let d = n.pos.minus(avg);
                // f = -k(d-d0)d_hat
                //   = -k(|d|-length)d/|d|
                //   = -k(1-length/|d|)d
                let f = d.scale(1-this.length/(d.mag()+1e-300));
                n.force = n.force.plus(f.scale(-this.strength));
            }
            this.draw();
        }
    }

    var nodes = [];
    var edges = [];
    var nodeMode_v = 0;
    var nodeMode = 0;

    for (let n of htmlnodes){
	//n.setAttribute("onclick","nodeclick("+nodes.length+");");
        let node = new Node(new vec2(Math.random()*40-20,Math.random()*40-20),n);
	registernode(node);
    }
    function connect(na,nb,length=0.2,linkStrength=0.1,linkStyle={stroke:"red","stroke-width":"0.01"}){
        let edge = new Edge([na,nb],length,linkStrength,linkStyle); 
        //na.edges.push(edge);
        //nb.edges.push(edge);
        //edge.draw();
        edges.push(edge);
    }

    function connectRandom(n){
        for (let i = 0; i < n; i++){
            let a = Math.floor(Math.random()*nodes.length);
            let b = Math.floor(Math.random()*nodes.length);
            connect(nodes[a],nodes[b]);
        }
    }
    
    var gen = iter();
    
    function frame(){
        gen.next();
        setTimeout(frame,100);
    }
    //frame();
    var mousePathPos;
    var current_time = undefined;
    let regenAmount = 0;
    let regenDebt = 0;
    function nodeStep(time){
	//zoom = zoom.scale(0.9).plus(zoom_to.scale(0.1));
	//pan = pan.scale(0.9).plus(pan_to.scale(0.1));
	updateViewbox();
	
        if (mousePath == ""){
            mousePathPos = toZ(mousePos);
            mousePath = "M "+toSVG(mousePathPos).str()+" L ";
        }
        for (let i = 0; i < 2; i++){
            let g = mandGrad(256,mousePathPos);
            mousePathPos = mousePathPos.plus(g.unscale((g.mag()+1e-10)*1000));
            mousePath += toSVG(mousePathPos).str()+" ";

        }

        document.getElementById("mousePath").setAttribute("d",mousePath);
	let width = zoom.mag()*0.005*SVGzoom;
	document.getElementById("mousePath").setAttribute("stroke-width",width+"");
        if (current_time === undefined){
            current_time = time;
        }
        let dt = time-current_time;
        current_time = time;
	dt *= (1-nodeMode_v)**5;
        for (let n of nodes){
            n.step(dt);
            let d = toZ(mousePos).minus(n.pos);
            //n.force = n.force.plus(d.unscale(-((d.mag2()**2)*500+1e-5)));
        }
        for (let e of edges){
            e.step(dt);
        }
	regenDebt = Math.min(16,regenDebt+lerp(4,regenAmount,Math.min(1,(nodeMode_v**5)*1.01)));
	for (; regenDebt > 0; regenDebt --){
	    render_hair(Math.random()*64);
	}
	regenAmount = 0;
	nodeMode_v = lerp(nodeMode_v,nodeMode,0.025);
        window.requestAnimationFrame(nodeStep);
    }
    nodeStep();

    
    connectRandom(10);




    addEventListener("resize", (event) => {});
    
    
    addEventListener('wheel', (event) => {//todo: use scroll event or pinch-zoom event if exists
	let dest = toZ(mousePos);
	regenAmount += Math.abs(event.wheelDelta);
	let amount = Math.exp(event.wheelDelta*0.001);
	zoom = zoom.scale(amount);
	pan = dest.scale(1-amount).plus(pan.scale(amount));
	cancel(event);
    });
    let mouseDown = false;
    let mouseDownPos = new vec2(0,0);
    addEventListener("mousedown", (event) => {
	mouseDownPos = mousePos.scale(1);
	mouseDown = true;
	cancel(event);
    });
    addEventListener("mouseup", (event) => {
	mouseDown = false;
	if (movingNode !== undefined){
	    movingNode.onmouseup(event);
	}
    });
    addEventListener("mousemove", (event) => {
	if (mouseDown){
	    let delta = mousePos.minus(mouseDownPos);
	    pan = pan.minus(toDZ(delta));
	    regenAmount += delta.mag()*0.25;
	    mouseDownPos = mousePos.scale(1);
	}
    });
    addEventListener("keydown", (event) => {
	console.log(event);
	if (event.key === 'Shift'){
	    nodeMode = 1-nodeMode;
	}
    })
    /*addEventListener("keyup", (event) => {
	console.log(event);
	if (event.key === 'Shift'){
	    nodeMode = 0;
	}
    })*/


    //todo sshift click for node mode (Attach nodes to eachother)
    //todo patches for zoom in

    function render_hair(n){//todo make faster.
	let iters = 256;
	let maxLines = 512;
	let tries = 16;
	let pt;
	do {
	    pt = (new vec2(Math.random()*2-1,Math.random()*2-1)).cmult(zoom).cadd(pan);
	    for (let i = (1-Math.random()**2)*(tries*4); i > 1 ; i--){
		let gz = mandGrad(iters,pt)
		pt = pt.plus(gz.unscale(gz.mag2()*10+1));
		if (mand_i(pt,iters) > iters){
		    pt = (new vec2(Math.random()*2-1,Math.random()*2-1)).cmult(zoom).cadd(pan);
		}
	    }
	    tries--;
	} while (tries > 0 && mand_i(pt,iters) > iters)
	if (mand_i(pt,iters) > iters){
	    return;
	}

	//let level = mandelbrott_dist(256,pt);
	//let width = 1/(level+5)**2;
	//let width = 1/(mandGrad(256,pt).mag()**1.5+1);
	let r = "M "+toSVG(pt).str() + " L ";
	let length = 0;
	let n0 = n;
	for (let p of trace_circle(iters,pt,Math.random()>0.5?0.25:-0.25)){
	    //console.log(p);
	    r += toSVG(p).str()+" ";
	    n -= 1;
	    if (n < 0){
		break
	    }
	    length += p.minus(pt).mag();
	    pt = p;
	}
	let width = Math.min(length/n0,0.1);
	let pathn = document.createElementNS("http://www.w3.org/2000/svg","path");
	pathn.setAttribute("fill","none");
        pathn.setAttribute("stroke",scol(mandelbrott_dist(iters,pt)));
	pathn.setAttribute("stroke-width",""+width*SVGzoom);
        pathn.setAttribute("d",r);
        svg.children[1].appendChild(pathn);
	if (svg.children[1].children.length > maxLines){
	    svg.children[1].removeChild(svg.children[1].children[0]);
	}
    }





    function dropHandler(ev){
	console.log(ev);

	ev.preventDefault();
	let files = [];
	if (ev.dataTransfer.items) {
	    // Use DataTransferItemList interface to access the file(s)
	    [...ev.dataTransfer.items].forEach((item, i) => {
		// If dropped items aren't files, reject them
		if (item.kind === 'file') {
		    const file = item.getAsFile();
		    files.push(file);
		    console.log(`… file[${i}].name = ${file.name}`);
		}
	    });
	} else {
	    // Use DataTransfer interface to access the file(s)
	    [...ev.dataTransfer.files].forEach((file, i) => {
		files.push(file)
		console.log(`… file[${i}].name = ${file.name}`);
	    });
	}
	console.log(files);
	//https://stackoverflow.com/questions/3814231/loading-an-image-to-a-img-from-input-file
	if (FileReader && files && files.length) {
	    for (let i = 0; i < files.length; i++){
		let fr = new FileReader();
		let img = document.createElement('img');
		fr.onload = function () {
		    img.src = fr.result;
		}
		fr.readAsDataURL(files[i]);
		let div = document.createElement('div');
		div.appendChild(img)
		htmlnodes_parent.appendChild(div);
		let scale = zoom.mag()/4/16;
		let node = new Node(toZ(mousePos),img,0.125);
		registernode(node);
		node.followingMouse = 1;
	    }
	}
	
	// Not supported
	else {
            // fallback -- perhaps submit the input to an iframe and temporarily store
            // them on the server until the user's session ends.
	    console.log("FileReader not supported or no files");
	}
    }
    function registernode(node){
	let id = nodes.length;
	let div = node.content;
	/*div.setAttribute("onclick","(e)=>nodes["+id+"].onclick(e)");
	div.setAttribute("onmousedown","(e)=>nodes["+id+"].onmousedown(e)");
	div.setAttribute("onmouseup","(e)=>nodes["+id+"].onmouseup(e)");
	div.setAttribute("onmousemove","(e)=>nodes["+id+"].onmousemove(e)");*/
	div.onclick = node.onclick.bind(node);
	div.onmousedown = node.onmousedown.bind(node);
	div.onmouseup = node.onmouseup.bind(node);
	div.onmousemove = node.onmousemove.bind(node);
	nodes.push(node);
    }
  
    function dragOverHandler(ev) {
	ev.preventDefault();
    }
    function nodemousedown(id){
	if (id < nodes.length){
	    nodes[id].mousedown();
	}
    }
    function nodemouseup(id){
	if (id < nodes.length){
	    nodes[id].mouseup();
	}
    }
    function nodemousemove(id){
	if (id < nodes.length){
	    nodes[id].mousemove();
	}
    }
    function nodeclick(id){
	if (id < nodes.length){
	    nodes[id].mouseclick();
	}
    }


    function cancel(event){
	if (event.stopPropagation) {
	    event.stopPropagation();   // W3C model
	} else {
	    event.cancelBubble = true; // IE model
	}
    }




    

    
  </script>
</body>
</html>








